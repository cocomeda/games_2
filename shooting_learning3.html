<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Monster Training - Swarm Intelligence (Metabolism)</title>
<style>
    body { margin:0; background:#0a0a0a; overflow:hidden; color:#00ffcc; font-family:monospace; }
    canvas { display:block; }
    .ui { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.8); padding:15px; border:1px solid #00ffcc; width:280px; }
    .stat { display:flex; justify-content:space-between; margin:3px 0; }
    .btn { background:#004433; color:#00ffcc; border:1px solid #00ffcc; padding:8px; cursor:pointer; width:100%; margin-top:10px; font-family:monospace; }
    input { margin-top:5px; width:100%; }
    b { font-size: 1.2em; text-shadow: 0 0 5px #00ffcc; }
</style>
</head>
<body>

<div class="ui">
    <b>EVOLUTION PHASE: METABOLISM</b>
    <hr>
    <div class="stat">Pop: <span id="pop">0</span></div>
    <div class="stat">Bait A: <span id="cntA">0</span></div>
    <div class="stat">Bait B: <span id="cntB">0</span></div>
    <div class="stat">Max Life: <span id="maxAge">0</span></div>
    <hr>
    <button class="btn" onclick="downloadBrain()">SAVE BEST BRAIN (.json)</button>
    <input type="file" id="loadBrain" accept=".json">
</div>

<canvas id="sim"></canvas>

<script>
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');

let monsters = [];
let bullets = [];
let foods = [];
let explosions = [];
let maxAge = 0;
let loadedBrain = null;

/* ================= BRAIN ================= */
class Brain {
    constructor(weights = null) {
        this.inputSize = 10; 
        this.hiddenSize = 12;
        this.outputSize = 2;
        if (weights) { 
            this.w1 = weights.w1; 
            this.w2 = weights.w2; 
        } else {
            this.w1 = Array.from({length: this.inputSize * this.hiddenSize}, () => Math.random() * 2 - 1);
            this.w2 = Array.from({length: this.hiddenSize * this.outputSize}, () => Math.random() * 2 - 1);
        }
    }
    predict(inputs) {
        let hidden = new Array(this.hiddenSize).fill(0);
        for(let i=0; i<this.hiddenSize; i++) {
            for(let j=0; j<this.inputSize; j++) hidden[i] += inputs[j] * this.w1[i * this.inputSize + j];
            hidden[i] = Math.tanh(hidden[i]);
        }
        let outputs = [0, 0];
        for(let i=0; i<2; i++) {
            for(let j=0; j<this.hiddenSize; j++) outputs[i] += hidden[j] * this.w2[i * this.hiddenSize + j];
            outputs[i] = Math.tanh(outputs[i]);
        }
        return outputs;
    }
    mutate() {
        const m = (w) => (Math.random() < 0.1 ? w + (Math.random() * 2 - 1) * 0.5 : w);
        return new Brain({ w1: this.w1.map(m), w2: this.w2.map(m) });
    }
}

/* ================= MONSTER ================= */
class Monster {
    constructor(x, y, brain = null) {
        this.x = x; this.y = y;
        this.angle = Math.random() * Math.PI * 2;
        this.energy = 100;
        this.age = 0;
        this.eatBCount = 0;
        this.brain = brain || new Brain();
    }

    getSensors() {
        const nB = this.getNearest(bullets, 600);
        const nF = this.getNearest(foods, 600);
        const nM = this.getNearest(monsters.filter(m => m !== this), 400);

        return [
            nB.dist, nB.angle,
            nF.dist, nF.angle,
            nM.dist, nM.angle,
            this.energy / 100,
            Math.cos(this.angle), Math.sin(this.angle),
            1
        ];
    }

    getNearest(list, maxRange) {
        let found = list.reduce((prev, curr) => {
            let d = Math.hypot(curr.x - this.x, curr.y - this.y);
            return d < prev.d ? {d: d, obj: curr} : prev;
        }, {d: maxRange, obj: null});

        if (found.obj) {
            let ang = Math.atan2(found.obj.y - this.y, found.obj.x - this.x) - this.angle;
            return { dist: found.d / maxRange, angle: Math.sin(ang) };
        }
        return { dist: 1, angle: 0 };
    }

    update() {
        this.age++;

        const [turn, accel] = this.brain.predict(this.getSensors());
        this.angle += turn * 0.15;

        // ---- 速度 ----
        const speed = Math.max(0, (accel + 1) * 2.5);

        // ---- 移動 ----
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;

        // ---- 画面ループ ----
        if(this.x < 0) this.x = canvas.width; 
        if(this.x > canvas.width) this.x = 0;
        if(this.y < 0) this.y = canvas.height; 
        if(this.y > canvas.height) this.y = 0;

        // ---- エネルギー消費モデル（基礎代謝＋速度依存）----
        const basal = 0.05;                  // 基礎代謝
        const moveCost = 0.03 * speed * speed; // 速度の2乗コスト
        const turnCost = 0.02 * Math.abs(turn); // 旋回コスト

        if (monsters.length > 1) {
            this.energy -= (basal + moveCost + turnCost);
        }

        if (this.age > maxAge) maxAge = this.age;
        return this.energy > 0;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = (monsters.length === 1) ? '#ff00ff' : '#00ffcc';
        ctx.beginPath(); 
        ctx.moveTo(10, 0); 
        ctx.lineTo(-6, -6); 
        ctx.lineTo(-6, 6); 
        ctx.fill();
        ctx.restore();
    }
}

/* ================= BULLET ================= */
class Bullet {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height;
        this.speed = [6, 9, 12][Math.floor(Math.random()*3)]; // 高速化
    }
    update() { this.y -= this.speed; return this.y > -20; }
    draw() { ctx.fillStyle = '#ff4444'; ctx.fillRect(this.x, this.y, 3, 14); }
}

/* ================= FOOD ================= */
class Food {
    constructor(type) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.type = type;
    }
    draw() {
        ctx.fillStyle = this.type === 'A' ? '#00ff00' : '#0088ff';
        ctx.beginPath(); 
        ctx.arc(this.x, this.y, 4, 0, 7); 
        ctx.fill();
    }
}

/* ================= EXPLOSION ================= */
class Explosion {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.life = 20;
        this.particles = Array.from({length: 12}, () => ({
            x: x, y: y,
            vx: (Math.random()*2-1)*3,
            vy: (Math.random()*2-1)*3
        }));
    }
    update() {
        this.life--;
        this.particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
        });
        return this.life > 0;
    }
    draw() {
        ctx.fillStyle = 'rgba(255,120,0,0.8)';
        this.particles.forEach(p => ctx.fillRect(p.x, p.y, 2, 2));
    }
}

/* ================= INIT ================= */
function init() {
    canvas.width = window.innerWidth; 
    canvas.height = window.innerHeight;
    monsters = [];
    bullets = [];
    foods = [];
    explosions = [];
    maxAge = 0;

    for(let i=0; i<20; i++) {
        monsters.push(new Monster(
            Math.random()*canvas.width, 
            Math.random()*canvas.height,
            loadedBrain ? loadedBrain.mutate() : null
        ));
    }
}

/* ================= LOOP ================= */
function loop() {
    ctx.fillStyle = 'rgba(10, 10, 10, 0.4)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (monsters.length <= 10) 
        for(let i=0; i<2; i++) 
            foods.push(new Food(Math.random() > 0.5 ? 'A' : 'B'));

    if (Math.random() < 0.06) bullets.push(new Bullet());
    if (Math.random() < 0.03) foods.push(new Food('A'));

    bullets = bullets.filter(b => { b.draw(); return b.update(); });
    foods.forEach(f => f.draw());
    explosions = explosions.filter(e => { e.draw(); return e.update(); });

    for (let i = monsters.length - 1; i >= 0; i--) {
        const m = monsters[i];
        if (!m.update()) { monsters.splice(i, 1); continue; }
        m.draw();

        // ---- 弾丸ヒット ----
        if (monsters.length > 1) {
            bullets.forEach((b, bi) => {
                if (Math.hypot(m.x - b.x, m.y - b.y) < 15) {
                    explosions.push(new Explosion(m.x, m.y));
                    monsters.splice(i, 1); 
                    bullets.splice(bi, 1); 
                }
            });
        }

        // ---- 餌 ----
        foods.forEach((f, fi) => {
            if (Math.hypot(m.x - f.x, m.y - f.y) < 15) {
                // 即全回復ではなく部分回復
                m.energy = Math.min(100, m.energy + 40);

                if (f.type === 'A' || (f.type === 'B' && ++m.eatBCount >= 2)) {
                    monsters.push(new Monster(m.x, m.y, m.brain.mutate()));
                    m.eatBCount = 0;
                }
                foods.splice(fi, 1);
            }
        });
    }

    document.getElementById('pop').innerText = monsters.length;
    document.getElementById('maxAge').innerText = maxAge;
    document.getElementById('cntA').innerText = foods.filter(f=>f.type==='A').length;
    document.getElementById('cntB').innerText = foods.filter(f=>f.type==='B').length;

    requestAnimationFrame(loop);
}

/* ================= SAVE / LOAD ================= */
function downloadBrain() {
    const best = monsters.reduce((p, c) => p.age > c.age ? p : c);
    const blob = new Blob([JSON.stringify({w1: best.brain.w1, w2: best.brain.w2})], {type: "application/json"});
    const a = document.createElement("a"); 
    a.href = URL.createObjectURL(blob); 
    a.download = "swarm_brain.json"; 
    a.click();
}

document.getElementById("loadBrain").addEventListener("change", e => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
        const data = JSON.parse(reader.result);
        loadedBrain = new Brain(data);
        init(); // 読み込んだ脳で再初期化
    };
    reader.readAsText(file);
});

/* ================= START ================= */
init(); 
loop();
</script>
</body>
</html>
