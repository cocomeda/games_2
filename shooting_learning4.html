<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Monster Training - Brain Loader</title>
<style>
    body { margin:0; background:#05050a; overflow:hidden; color:#00ffcc; font-family:monospace; }
    canvas { display:block; }
    .ui { position:absolute; top:20px; left:20px; background:rgba(0,0,0,0.85); padding:15px; border-radius:8px; border:1px solid #00ffcc; width:280px; pointer-events:none; z-index:100; }
    .ui * { pointer-events: auto; }
    .stat { display:flex; justify-content:space-between; margin:8px 0; font-size:14px; }
    .control-group { margin-top: 15px; border-top: 1px solid #333; padding-top: 10px; }
    input[type="range"] { width: 100%; cursor: pointer; accent-color: #ff4444; }
    .btn { background:#002211; color:#00ffcc; border:1px solid #00ffcc; padding:10px; cursor:pointer; width:100%; margin-top:5px; font-weight:bold; font-size: 12px; }
    .btn:hover { background:#00ffcc; color:#002211; }
    .load-btn { background:#221100; color:#ffaa00; border:1px solid #ffaa00; }
    .load-btn:hover { background:#ffaa00; color:#221100; }
    b { font-size: 1.1em; text-shadow: 0 0 5px #00ffcc; color: #fff; }
    #fileInput { display: none; }
</style>
</head>
<body>

<div class="ui">
    <b>ARENA: INTELLIGENCE LOADER</b>
    <hr style="border:0; border-top:1px solid #333;">
    <div class="stat">Pop: <span id="pop">0</span></div>
    <div class="stat">Max Age: <span id="maxAge">0</span></div>
    
    <div class="control-group">
        <label>弾丸の量: <span id="rateVal">8</span>%</label>
        <input type="range" id="bulletRate" min="0" max="50" value="8">
    </div>

    <hr style="border:0; border-top:1px solid #333;">
    <button class="btn load-btn" onclick="document.getElementById('fileInput').click()">LOAD BRAIN (.json)</button>
    <input type="file" id="fileInput" accept=".json" onchange="loadBrain(event)">
    
    <button class="btn" onclick="downloadBrain()">SAVE BRAIN (.json)</button>
    <p style="font-size:10px; color:#888; margin-top:5px;">※読み込むと全員に知能が上書きされます</p>
</div>

<canvas id="sim"></canvas>

<script>
// --- 基本設定とクラス定義 (v8.0を継承) ---
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');
let monsters = [];
let bullets = [];
let foods = [];
let obstacles = [];
let particles = [];
let maxAge = 0;
let frameCount = 0;

const rateSlider = document.getElementById('bulletRate');
const rateLabel = document.getElementById('rateVal');

class Brain {
    constructor(weights = null) {
        this.inputSize = 14; this.hiddenSize = 16; this.outputSize = 2;
        if (weights) { this.w1 = weights.w1; this.w2 = weights.w2; } 
        else {
            this.w1 = Array.from({length: this.inputSize * this.hiddenSize}, () => Math.random() * 2 - 1);
            this.w2 = Array.from({length: this.hiddenSize * this.outputSize}, () => Math.random() * 2 - 1);
        }
    }
    predict(inputs) {
        let hidden = new Array(this.hiddenSize).fill(0);
        for(let i=0; i<this.hiddenSize; i++) {
            for(let j=0; j<this.inputSize; j++) hidden[i] += inputs[j] * this.w1[i * this.inputSize + j];
            hidden[i] = Math.tanh(hidden[i]);
        }
        let outputs = [0, 0];
        for(let i=0; i<2; i++) {
            for(let j=0; j<this.hiddenSize; j++) outputs[i] += hidden[j] * this.w2[i * this.hiddenSize + j];
            outputs[i] = Math.tanh(outputs[i]);
        }
        return outputs;
    }
    mutate() {
        const m = (w) => (Math.random() < 0.1 ? w + (Math.random() * 2 - 1) * 0.4 : w);
        return new Brain({ w1: this.w1.map(m), w2: this.w2.map(m) });
    }
}

// --- 読み込み処理 ---
function loadBrain(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (!data.w1 || !data.w2) throw new Error("Invalid brain data");
            
            // 全てのモンスターに読み込んだ脳を適用（少しだけ変異させて多様性を持たせる）
            monsters.forEach(m => {
                m.brain = new Brain({ w1: [...data.w1], w2: [...data.w2] });
                if (monsters.length > 1) m.brain = m.brain.mutate(); 
            });
            
            alert("学習データを読み込みました。エリート個体の知能が全員に継承されました。");
        } catch (err) {
            alert("ファイルの形式が正しくありません。");
        }
    };
    reader.readAsText(file);
}

// --- 以下、シミュレーションロジック (v8.0同等) ---

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color; this.size = Math.random() * 3 + 1;
        this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8; this.life = 1.0;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; return this.life > 0; }
    draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1; }
}
function createExplosion(x, y, color, count = 10) { for(let i=0; i<count; i++) particles.push(new Particle(x, y, color)); }

class Obstacle {
    constructor(x, y) { this.x = x; this.y = y; this.w = 80; this.h = 30; this.hp = 20; }
    draw() {
        ctx.fillStyle = "#282d3c"; ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2;
        ctx.fillRect(this.x, this.y, this.w, this.h); ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = "#ff4444"; ctx.fillRect(this.x, this.y - 8, this.w * (this.hp / 20), 3);
    }
}

class Monster {
    constructor(x, y, brain = null) {
        this.x = x; this.y = y; this.angle = Math.random() * Math.PI * 2;
        this.energy = 100; this.age = 0; this.eatBCount = 0;
        this.brain = brain || new Brain();
        this.memBulletDist = 1; this.memBulletAngle = 0;
    }
    getSensors() {
        const nB = this.getNearest(bullets, 600);
        const nF = this.getNearest(foods, 600);
        const nM = this.getNearest(monsters.filter(m => m !== this), 400);
        const nO = this.getNearestObs(600);
        if (nB.dist < 1) { this.memBulletDist = nB.dist; this.memBulletAngle = nB.angle; } 
        else { this.memBulletDist = Math.min(1, this.memBulletDist + 0.02); }
        return [nB.dist, nB.angle, nF.dist, nF.angle, nM.dist, nM.angle, nO.dist, nO.angle, this.memBulletDist, this.memBulletAngle, this.energy/100, Math.cos(this.angle), Math.sin(this.angle), 1];
    }
    getNearest(list, maxRange) {
        let found = list.reduce((prev, curr) => {
            let d = Math.hypot(curr.x - this.x, curr.y - this.y);
            return d < prev.d ? {d: d, obj: curr} : prev;
        }, {d: maxRange, obj: null});
        if (found.obj) {
            let ang = Math.atan2(found.obj.y - this.y, found.obj.x - this.x) - this.angle;
            return { dist: found.d / maxRange, angle: Math.sin(ang) };
        }
        return { dist: 1, angle: 0 };
    }
    getNearestObs(maxRange) {
        let found = obstacles.reduce((prev, curr) => {
            let cx = curr.x + curr.w/2; let cy = curr.y + curr.h/2;
            let d = Math.hypot(cx - this.x, cy - this.y);
            return d < prev.d ? {d: d, obj: curr} : prev;
        }, {d: maxRange, obj: null});
        if (found.obj) {
            let cx = found.obj.x + found.obj.w/2; let cy = found.obj.y + found.obj.h/2;
            let ang = Math.atan2(cy - this.y, cx - this.x) - this.angle;
            return { dist: found.d / maxRange, angle: Math.sin(ang) };
        }
        return { dist: 1, angle: 0 };
    }
    update() {
        this.age++; if (monsters.length > 1) this.energy -= 0.18;
        const [turn, accel] = this.brain.predict(this.getSensors());
        this.angle += turn * 0.15;
        const speed = (accel + 1) * 2.5;
        let nextX = this.x + Math.cos(this.angle) * speed;
        let nextY = this.y + Math.sin(this.angle) * speed;
        let canMove = true;
        if (nextX < 15 || nextX > canvas.width - 15 || nextY < 15 || nextY > canvas.height - 15) canMove = false;
        for(let obs of obstacles) { if (nextX > obs.x && nextX < obs.x + obs.w && nextY > obs.y && nextY < obs.y + obs.h) { canMove = false; break; } }
        if(canMove) { this.x = nextX; this.y = nextY; }
        return this.energy > 0;
    }
    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.fillStyle = (monsters.length === 1) ? '#ff00ff' : '#00ffcc';
        ctx.beginPath(); ctx.moveTo(12, 0); ctx.lineTo(-8, -7); ctx.lineTo(-8, 7); ctx.fill();
        ctx.restore();
    }
}

class Bullet {
    constructor() { this.x = Math.random() * canvas.width; this.y = canvas.height + 10; this.speed = [4, 6, 9][Math.floor(Math.random()*3)]; }
    update() {
        this.y -= this.speed;
        for(let i=obstacles.length-1; i>=0; i--) {
            let o = obstacles[i];
            if(this.x > o.x && this.x < o.x + o.w && this.y > o.y && this.y < o.y + o.h) {
                o.hp--; createExplosion(this.x, this.y, "#ffcc00", 6);
                if(o.hp <= 0) { createExplosion(o.x + o.w/2, o.y + o.h/2, "#00ffcc", 20); obstacles.splice(i, 1); }
                return false;
            }
        }
        return this.y > -20;
    }
    draw() { ctx.fillStyle = '#ff4444'; ctx.fillRect(this.x, this.y, 3, 15); }
}

class Food {
    constructor(type) {
        this.x = 40 + Math.random() * (canvas.width-80);
        this.y = 40 + Math.random() * (canvas.height-80);
        this.type = type;
    }
    draw() { ctx.fillStyle = this.type === 'A' ? '#0f0' : '#08f'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 7); ctx.fill(); }
}

function init() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    monsters = []; bullets = []; foods = []; obstacles = []; particles = [];
    for(let i=0; i<15; i++) monsters.push(new Monster(canvas.width/2, canvas.height/2));
    for(let i=0; i<6; i++) obstacles.push(new Obstacle(Math.random()*(canvas.width-150)+75, Math.random()*(canvas.height-250)+100));
}

function loop() {
    frameCount++;
    ctx.fillStyle = '#05050a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#222'; ctx.lineWidth = 20; ctx.strokeRect(0,0,canvas.width,canvas.height);

    const spawnRate = parseInt(rateSlider.value) / 100;
    rateLabel.innerText = rateSlider.value;

    if (frameCount % 300 === 0 && obstacles.length < 10) {
        obstacles.push(new Obstacle(Math.random()*(canvas.width-150)+75, Math.random()*(canvas.height-250)+100));
    }
    if (monsters.length <= 10 && foods.length < 10) {
        for(let i=0; i<50; i++) foods.push(new Food(Math.random() > 0.5 ? 'A' : 'B'));
    }

    if (Math.random() < spawnRate) bullets.push(new Bullet());
    if (Math.random() < 0.02) foods.push(new Food('A'));

    obstacles.forEach(o => o.draw());
    bullets = bullets.filter(b => { b.draw(); return b.update(); });
    foods.forEach(f => f.draw());
    particles = particles.filter(p => { p.draw(); return p.update(); });

    for (let i = monsters.length - 1; i >= 0; i--) {
        const m = monsters[i];
        if (!m.update()) { monsters.splice(i, 1); continue; }
        m.draw();
        if (monsters.length > 1) {
            bullets.forEach((b, bi) => {
                if (Math.hypot(m.x - b.x, m.y - b.y) < 16) {
                    createExplosion(m.x, m.y, "#f00", 20);
                    monsters.splice(i, 1); bullets.splice(bi, 1);
                }
            });
        }
        foods.forEach((f, fi) => {
            if (Math.hypot(m.x - f.x, m.y - f.y) < 18) {
                m.energy = 100;
                if (f.type === 'A' || (f.type === 'B' && ++m.eatBCount >= 3)) {
                    monsters.push(new Monster(m.x, m.y, m.brain.mutate()));
                    m.eatBCount = 0;
                }
                foods.splice(fi, 1);
            }
        });
    }

    document.getElementById('pop').innerText = monsters.length;
    if(monsters.length > 0) {
        let currentBest = Math.max(...monsters.map(m => m.age));
        if(currentBest > maxAge) maxAge = currentBest;
    }
    document.getElementById('maxAge').innerText = maxAge;
    requestAnimationFrame(loop);
}

function downloadBrain() {
    if (monsters.length === 0) return;
    const best = monsters.reduce((p, c) => p.age > c.age ? p : c);
    const blob = new Blob([JSON.stringify({w1: best.brain.w1, w2: best.brain.w2})], {type: "application/json"});
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "monster_brain.json"; a.click();
}

window.addEventListener('resize', init);
init(); loop();
</script>
</body>
</html>
