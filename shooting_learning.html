<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Monster Training - Swarm Intelligence</title>
<style>
    body { margin:0; background:#0a0a0a; overflow:hidden; color:#00ffcc; font-family:monospace; }
    canvas { display:block; }
    .ui { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.8); padding:15px; border:1px solid #00ffcc; width:280px; pointer-events:none; }
    .ui * { pointer-events: auto; }
    .stat { display:flex; justify-content:space-between; margin:3px 0; }
    .btn { background:#004433; color:#00ffcc; border:1px solid #00ffcc; padding:8px; cursor:pointer; width:100%; margin-top:10px; font-family:monospace; }
    b { font-size: 1.2em; text-shadow: 0 0 5px #00ffcc; }
</style>
</head>
<body>

<div class="ui">
    <b>EVOLUTION PHASE: SWARM</b>
    <hr>
    <div class="stat">Pop: <span id="pop">0</span></div>
    <div class="stat">Bait A: <span id="cntA">0</span></div>
    <div class="stat">Bait B: <span id="cntB">0</span></div>
    <div class="stat">Max Life: <span id="maxAge">0</span></div>
    <hr>
    <button class="btn" onclick="downloadBrain()">SAVE BEST BRAIN (.json)</button>
</div>

<canvas id="sim"></canvas>

<script>
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');
let monsters = [];
let bullets = [];
let foods = [];
let maxAge = 0;

class Brain {
    constructor(weights = null) {
        this.inputSize = 10; 
        this.hiddenSize = 12; // 仲間が増えたので少し複雑に
        this.outputSize = 2;
        if (weights) { this.w1 = weights.w1; this.w2 = weights.w2; } 
        else {
            this.w1 = Array.from({length: this.inputSize * this.hiddenSize}, () => Math.random() * 2 - 1);
            this.w2 = Array.from({length: this.hiddenSize * this.outputSize}, () => Math.random() * 2 - 1);
        }
    }
    predict(inputs) {
        let hidden = new Array(this.hiddenSize).fill(0);
        for(let i=0; i<this.hiddenSize; i++) {
            for(let j=0; j<this.inputSize; j++) hidden[i] += inputs[j] * this.w1[i * this.inputSize + j];
            hidden[i] = Math.tanh(hidden[i]);
        }
        let outputs = [0, 0];
        for(let i=0; i<2; i++) {
            for(let j=0; j<this.hiddenSize; j++) outputs[i] += hidden[j] * this.w2[i * this.hiddenSize + j];
            outputs[i] = Math.tanh(outputs[i]);
        }
        return outputs;
    }
    mutate() {
        const m = (w) => (Math.random() < 0.1 ? w + (Math.random() * 2 - 1) * 0.5 : w);
        return new Brain({ w1: this.w1.map(m), w2: this.w2.map(m) });
    }
}

class Monster {
    constructor(x, y, brain = null) {
        this.x = x; this.y = y;
        this.angle = Math.random() * Math.PI * 2;
        this.energy = 100;
        this.age = 0;
        this.eatBCount = 0;
        this.brain = brain || new Brain();
    }

    getSensors() {
        const nB = this.getNearest(bullets, 600);
        const nF = this.getNearest(foods, 600);
        const nM = this.getNearest(monsters.filter(m => m !== this), 400); // 仲間の探索

        return [
            nB.dist, nB.angle,
            nF.dist, nF.angle,
            nM.dist, nM.angle, // 仲間の位置
            this.energy / 100,
            Math.cos(this.angle), Math.sin(this.angle),
            1
        ];
    }

    getNearest(list, maxRange) {
        let found = list.reduce((prev, curr) => {
            let d = Math.hypot(curr.x - this.x, curr.y - this.y);
            return d < prev.d ? {d: d, obj: curr} : prev;
        }, {d: maxRange, obj: null});

        if (found.obj) {
            let ang = Math.atan2(found.obj.y - this.y, found.obj.x - this.x) - this.angle;
            return { dist: found.d / maxRange, angle: Math.sin(ang) };
        }
        return { dist: 1, angle: 0 };
    }

    update() {
        this.age++;
        if (monsters.length > 1) this.energy -= 0.15; // 最後の1匹以外は腹が減る

        const [turn, accel] = this.brain.predict(this.getSensors());
        this.angle += turn * 0.15;
        const speed = (accel + 1) * 2.5;
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;

        if(this.x < 0) this.x = canvas.width; if(this.x > canvas.width) this.x = 0;
        if(this.y < 0) this.y = canvas.height; if(this.y > canvas.height) this.y = 0;

        if (this.age > maxAge) maxAge = this.age;
        return this.energy > 0;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.fillStyle = (monsters.length === 1) ? '#ff00ff' : '#00ffcc';
        ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-6, -6); ctx.lineTo(-6, 6); ctx.fill();
        ctx.restore();
    }
}

// 他の要素（Bullet, Food）とループ処理は前回のロジックを継承...
class Bullet {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = canvas.height;
        this.speed = [3, 5, 8][Math.floor(Math.random()*3)];
    }
    update() { this.y -= this.speed; return this.y > -20; }
    draw() { ctx.fillStyle = '#ff4444'; ctx.fillRect(this.x, this.y, 3, 12); }
}

class Food {
    constructor(type) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.type = type;
    }
    draw() {
        ctx.fillStyle = this.type === 'A' ? '#00ff00' : '#0088ff';
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, 7); ctx.fill();
    }
}

function init() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    for(let i=0; i<20; i++) monsters.push(new Monster(Math.random()*canvas.width, Math.random()*canvas.height));
}

function loop() {
    ctx.fillStyle = 'rgba(10, 10, 10, 0.4)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (monsters.length <= 10) for(let i=0; i<2; i++) foods.push(new Food(Math.random() > 0.5 ? 'A' : 'B'));
    if (Math.random() < 0.06) bullets.push(new Bullet());
    if (Math.random() < 0.03) foods.push(new Food('A'));

    bullets = bullets.filter(b => { b.draw(); return b.update(); });
    foods.forEach(f => f.draw());

    for (let i = monsters.length - 1; i >= 0; i--) {
        const m = monsters[i];
        if (!m.update()) { monsters.splice(i, 1); continue; }
        m.draw();

        // 当たり判定
        if (monsters.length > 1) {
            bullets.forEach((b, bi) => {
                if (Math.hypot(m.x - b.x, m.y - b.y) < 15) { monsters.splice(i, 1); bullets.splice(bi, 1); }
            });
        }
        foods.forEach((f, fi) => {
            if (Math.hypot(m.x - f.x, m.y - f.y) < 15) {
                m.energy = 100;
                if (f.type === 'A' || (f.type === 'B' && ++m.eatBCount >= 2)) {
                    monsters.push(new Monster(m.x, m.y, m.brain.mutate()));
                    m.eatBCount = 0;
                }
                foods.splice(fi, 1);
            }
        });
    }

    document.getElementById('pop').innerText = monsters.length;
    document.getElementById('maxAge').innerText = maxAge;
    document.getElementById('cntA').innerText = foods.filter(f=>f.type==='A').length;
    document.getElementById('cntB').innerText = foods.filter(f=>f.type==='B').length;
    requestAnimationFrame(loop);
}

function downloadBrain() {
    const best = monsters.reduce((p, c) => p.age > c.age ? p : c);
    const blob = new Blob([JSON.stringify({w1: best.brain.w1, w2: best.brain.w2})], {type: "application/json"});
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "swarm_brain.json"; a.click();
}

init(); loop();
</script>
</body>
</html>
