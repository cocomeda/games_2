<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Eco-Evolution v4.4 - Wall Damage</title>
    <style>
        body { margin:0; background:#050505; overflow:hidden; color:#0f0; font-family:'Consolas',monospace; }
        canvas { display:block; }
        .ui { 
            position:absolute; top:15px; left:15px; 
            background:rgba(0, 0, 0, 0.5); 
            padding:15px; border-radius:8px; border:1px solid rgba(0, 255, 204, 0.3); 
            min-width:280px; pointer-events: none;
            z-index: 100;
        }
        .controls { pointer-events: auto; }
        .red { color: #ff4444; } .white { color: #ffffff; } .cyan { color: #00ffcc; }
        hr { border:0; border-top:1px solid rgba(255,255,255,0.2); margin:10px 0; }
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top:10px; }
        button { background:rgba(50,50,50,0.8); color:#fff; border:1px solid #666; padding:5px; cursor:pointer; font-size:11px; }
        button:hover { background:rgba(80,80,80,0.9); }
        #log { font-size:11px; color:#aaa; height: 1.2em; margin-top:5px; }
        input[type="file"] { display: none; }
        .total-box { font-size: 14px; border: 1px solid rgba(0,255,0,0.5); padding: 5px; text-align: center; margin-top: 5px; }
    </style>
</head>
<body>
    <div class="ui">
        <b>ECO-EVOLUTION v4.4</b><hr>
        <div style="display:flex; justify-content:space-between;">
            <span class="white">PREY: <span id="hCnt">0</span></span>
            <span class="red">HUNTER: <span id="pCnt">0</span></span>
        </div>
        <span class="cyan">MEAT: <span id="mCnt">0</span></span>
        <div class="total-box">TOTAL OBJECTS: <span id="tCnt">0</span></div>
        <hr>
        <div class="controls">
            <div class="btn-grid">
                <button onclick="saveBrain('prey')">草食保存</button>
                <button onclick="saveBrain('hunter')">肉食保存</button>
                <button onclick="triggerLoad('prey')">草食ロード</button>
                <button onclick="triggerLoad('hunter')">肉食ロード</button>
            </div>
        </div>
        <div id="log">Wall collision damage active.</div>
    </div>
    <input type="file" id="fileInput" accept=".json" onchange="handleFileLoad()">
    <canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let creatures = [];
let meats = [];
let loadTarget = 'prey';

class Brain {
    constructor(weights = null) {
        this.inputSize = 12;
        this.hiddenSize = 14; 
        if (weights && weights.w1.length === this.inputSize * this.hiddenSize) {
            this.w1 = new Float32Array(weights.w1).map(v => Math.random() < 0.08 ? v + (Math.random()-0.5)*0.2 : v);
            this.w2 = new Float32Array(weights.w2).map(v => Math.random() < 0.08 ? v + (Math.random()-0.5)*0.2 : v);
        } else {
            this.w1 = Float32Array.from({length: this.inputSize * this.hiddenSize}, () => Math.random() * 2 - 1);
            this.w2 = Float32Array.from({length: this.hiddenSize * 2}, () => Math.random() * 2 - 1);
        }
    }
    predict(inputs) {
        let h = new Float32Array(this.hiddenSize);
        for(let i=0; i<this.hiddenSize; i++) {
            let sum = 0;
            for(let j=0; j<this.inputSize; j++) sum += inputs[j] * this.w1[i * this.inputSize + j];
            h[i] = Math.tanh(sum);
        }
        let out = [0, 0];
        for(let i=0; i<2; i++) {
            let sum = 0;
            for(let j=0; j<this.hiddenSize; j++) sum += h[j] * this.w2[i * this.hiddenSize + j];
            out[i] = Math.tanh(sum);
        }
        return out;
    }
}

class Creature {
    constructor(x, y, type, brain = null) {
        this.x = x; this.y = y; this.type = type;
        this.energy = 100;
        this.angle = Math.random() * Math.PI * 2;
        this.brain = (brain instanceof Brain) ? brain : new Brain(brain);
        this.speed = 0;
    }

    update() {
        let inputs = [];
        let all = creatures;
        
        let enemies = all.filter(c => c.type !== this.type);
        let nearest = null, minDist = 2000;
        for(let e of enemies) {
            let d = Math.hypot(this.x - e.x, this.y - e.y);
            if(d < minDist) { minDist = d; nearest = e; }
        }
        inputs.push(minDist / 800, nearest ? (Math.atan2(nearest.y - this.y, nearest.x - this.x) - this.angle) / Math.PI : 0);

        let friends = all.filter(c => c.type === this.type && c !== this);
        let fCount = 0, fAvgDx = 0, fAvgDy = 0;
        friends.forEach(f => {
            let d = Math.hypot(f.x - this.x, f.y - this.y);
            if(d < 150) { fCount++; fAvgDx += (f.x - this.x); fAvgDy += (f.y - this.y); }
        });
        inputs.push(Math.min(fCount, 10) / 10, fCount > 0 ? (Math.atan2(fAvgDy, fAvgDx) - this.angle) / Math.PI : 0);

        let eCount = 0, eAvgDx = 0, eAvgDy = 0;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if(d < 150) { eCount++; eAvgDx += (e.x - this.x); eAvgDy += (e.y - this.y); }
        });
        inputs.push(Math.min(eCount, 10) / 10, eCount > 0 ? (Math.atan2(eAvgDy, eAvgDx) - this.angle) / Math.PI : 0);

        inputs.push(this.energy / 100, Math.min(this.x, canvas.width-this.x, this.y, canvas.height-this.y) / 50);
        inputs.push(this.speed / 5, Math.sin(this.angle));
        inputs.push(0, 0);

        if (this.energy > 0) {
            let [turn, accel] = this.brain.predict(inputs);
            this.angle += turn * 0.2;
            let speedMult = (this.type === 'hunter' && this.energy > 60) ? Math.max(0.5, 1.0 - ((this.energy - 60) / 40) * 0.5) : 1.0;
            this.speed = (this.type === 'prey' ? 3.0 : 3.2) * Math.abs(accel) * speedMult;
        } else { this.speed = 0; }

        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;

        // --- 壁反射とダメージ判定 ---
        let hitWall = false;
        if(this.x <= 0 || this.x >= canvas.width) {
            this.angle = Math.PI - this.angle;
            hitWall = true;
        }
        if(this.y <= 0 || this.y >= canvas.height) {
            this.angle = -this.angle;
            hitWall = true;
        }
        if(hitWall) {
            this.energy -= 1.0; // 壁ダメージ
            this.x = Math.max(0, Math.min(canvas.width, this.x));
            this.y = Math.max(0, Math.min(canvas.height, this.y));
        }

        if (this.type === 'hunter') {
            const loss = 0.04 + (this.speed ** 2) * 0.022;
            const hList = creatures.filter(c => c.type === 'hunter');
            if (!(hList.length <= 1 && this.energy <= loss)) this.energy -= loss;
            this.checkHunt();
        } else {
            this.energy -= 0.005;
            this.checkEatMeat();
        }
        return (this.type === 'prey' || this.energy > 0);
    }

    checkHunt() {
        if (this.energy > 95) return;
        for (let i = creatures.length - 1; i >= 0; i--) {
            let c = creatures[i];
            if (c.type === 'prey' && Math.hypot(this.x - c.x, this.y - c.y) < 8) {
                creatures.splice(i, 1);
                this.energy = 100;
                this.reproduce();
                break;
            }
        }
    }

    checkEatMeat() {
        for (let i = meats.length - 1; i >= 0; i--) {
            let m = meats[i];
            if (Math.hypot(this.x - m.x, this.y - m.y) < 8) {
                meats.splice(i, 1);
                this.energy = 100;
                this.reproduce();
                break;
            }
        }
    }

    reproduce() {
        const baby = new Creature(this.x, this.y, this.type, new Brain({
            w1: Array.from(this.brain.w1), w2: Array.from(this.brain.w2)
        }));
        baby.energy = 100;
        creatures.push(baby);
    }

    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.fillStyle = this.type === 'prey' ? (this.energy > 0 ? "#fff" : "#444") : "#f44";
        ctx.beginPath();
        if(this.type === 'prey') ctx.arc(0, 0, 1.2, 0, Math.PI*2);
        else { ctx.moveTo(3,0); ctx.lineTo(-2,-1.5); ctx.lineTo(-2,1.5); ctx.closePath(); }
        ctx.fill(); ctx.restore();
    }
}

function saveBrain(type) {
    const list = creatures.filter(c => c.type === type);
    if (list.length === 0) return;
    const target = list[Math.floor(Math.random() * list.length)];
    const data = { type: type, w1: Array.from(target.brain.w1), w2: Array.from(target.brain.w2) };
    const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `brain_v4.4_${type}.json`; a.click();
}

function triggerLoad(type) { loadTarget = type; document.getElementById('fileInput').click(); }
function handleFileLoad() {
    const file = document.getElementById('fileInput').files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            creatures.filter(c => c.type === loadTarget).forEach(c => c.brain = new Brain(data));
            document.getElementById('log').innerText = "Brain Loaded.";
        } catch(e) { document.getElementById('log').innerText = "Load Error."; }
    };
    reader.readAsText(file);
}

function init() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    creatures = []; meats = [];
    for(let i=0; i<180; i++) creatures.push(new Creature(Math.random()*canvas.width, Math.random()*canvas.height, 'prey'));
    for(let i=0; i<10; i++) creatures.push(new Creature(Math.random()*canvas.width, Math.random()*canvas.height, 'hunter'));
}

function animate() {
    ctx.fillStyle = 'rgba(5,5,5,0.4)'; ctx.fillRect(0,0,canvas.width, canvas.height);
    let pL = creatures.filter(c => c.type === 'prey');
    let hL = creatures.filter(c => c.type === 'hunter');

    if (pL.length <= 10 && meats.length > 0) {
        let m = meats.pop();
        const parent = pL[Math.floor(Math.random() * pL.length)];
        creatures.push(new Creature(m.x, m.y, 'prey', parent ? new Brain(parent.brain) : null));
    }

    for(let i = creatures.length-1; i >= 0; i--) {
        if(!creatures[i].update()) {
            if(creatures[i].type === 'hunter') meats.push({x: creatures[i].x, y: creatures[i].y});
            creatures.splice(i, 1);
        } else { creatures[i].draw(); }
    }

    meats.forEach(m => {
        ctx.fillStyle = "#0fc"; ctx.beginPath(); ctx.arc(m.x, m.y, 0.8, 0, Math.PI*2); ctx.fill();
    });

    document.getElementById('hCnt').innerText = pL.length;
    document.getElementById('pCnt').innerText = hL.length;
    document.getElementById('mCnt').innerText = meats.length;
    document.getElementById('tCnt').innerText = creatures.length + meats.length;
    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
init(); animate();
</script>
</body>
</html>
