<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>メダカ・サバイバル・デラックス</title>
<style>
    body { 
        text-align: center; 
        background: #b2ebf2; 
        font-family: sans-serif; 
        margin: 0; 
        overflow: hidden; 
        touch-action: none; /* ブラウザ標準のスクロール等を無効化 */
    }
    #game-container {
        position: relative;
        display: inline-block;
        margin: 10px auto;
        touch-action: none;
    }
    canvas { 
        border: 5px solid #01579b; 
        border-radius: 8px; 
        max-width: 95vw; 
        height: auto; 
        display: block; 
        box-shadow: 0 10px 30px rgba(0,0,0,0.3); 
        background: #87ceeb;
    }
    /* GIF画像をCanvasの上に浮かせるための設定 */
    .gif-overlay {
        position: absolute;
        pointer-events: none; /* これが重要：クリックを透過させてCanvasに届ける */
        z-index: 10;
        transform-origin: center center;
    }
</style>
</head>
<body>













 const waterSurface = 20;
let medaka = { x: 70, y: 200, w: 40, h: 20, dy: 0, gravity: 0.15, buoyancy: 0.25, stamina: 100 };
let obstacles = [], foods = [], enemies = [], bubbles = [], clouds = [];
let score = 0, frame = 0, isGameOver = false, gameOverTime = 0;
let highScore = parseInt(localStorage.getItem("medakaHighScore")) || 0;
let isPressing = false;

// --- 操作イベントの修正 ---
// 画面のどこを触っても反応するように window に対して登録
function onPress(e) {
    if (e) e.preventDefault();
    if (isGameOver) {
        if (Date.now() - gameOverTime < 1000) return;
        location.reload();
        return;
    }
    isPressing = true;
}

function onRelease(e) {
    if (e) e.preventDefault();
    isPressing = false;
}

// キーボード
window.addEventListener('keydown', (e) => { if(e.code === 'Space') onPress(e); });
window.addEventListener('keyup', (e) => { if(e.code === 'Space') onRelease(e); });

// マウス・タッチ（画面全体）
window.addEventListener('touchstart', onPress, { passive: false });
window.addEventListener('touchend', onRelease, { passive: false });
window.addEventListener('mousedown', onPress);
window.addEventListener('mouseup', onRelease);

function checkCollision(a, b, isFood = false) {
    let marginA = 0, marginB = 6;
    if (isFood) { marginA = -1; marginB = -1; }
    return (a.x + marginA < b.x + b.w - marginB && a.x + a.w - marginA > b.x + marginB && a.y + marginA < b.y + b.h - marginB && a.y + a.h - marginA > b.y + marginB);
}

function createCloud() {
    clouds.push({ x: canvas.width + Math.random() * 100, y: 10 + Math.random() * (waterSurface - 40), w: 60 + Math.random() * 40, h: 20 + Math.random() * 15, speed: 0.3 + Math.random() * 0.5 });
}

function update() {
    if (isGameOver) return;
    frame++;
    let gameSpeed = 4 + Math.floor(score / 300);
    score += gameSpeed * 0.05;

    if (isPressing) { medaka.stamina -= 0.15; } else { medaka.stamina -= 0.05; }
    if (medaka.stamina < 0) medaka.stamina = 0;

    const inWater = medaka.y >= waterSurface;
    if (inWater) {
        if (isPressing && medaka.stamina > 0) { medaka.dy -= medaka.buoyancy; } 
        else { medaka.dy += medaka.gravity * 0.6; }
    } else { medaka.dy += 0.7; }

    medaka.dy = Math.max(-3, Math.min(3, medaka.dy));
    medaka.y += medaka.dy;

    if (medaka.y > canvas.height - medaka.h) { medaka.y = canvas.height - medaka.h; medaka.dy = 0; }
    if (medaka.y < -30) { medaka.y = -30; medaka.dy = 0; }

    // 同期システム用の座標計算
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / canvas.width;

    // メダカDOM同期
    medakaDom.style.display = "block";
    medakaDom.style.left = (medaka.x * scale) + "px";
    medakaDom.style.top = (medaka.y * scale) + "px";
    medakaDom.style.width = ((medaka.w + 10) * scale) + "px";
    medakaDom.style.height = (medaka.h * scale) + "px";
    medakaDom.style.transform = `rotate(${medaka.dy * 5}deg)`;
    medakaDom.style.filter = medaka.stamina <= 0 ? 'grayscale(100%)' : 'none';

    // オブジェクト生成
    if (frame % 15 === 0) bubbles.push({ x: canvas.width, y: waterSurface + Math.random() * (canvas.height - waterSurface), r: Math.random() * 4 + 1 });
    bubbles.forEach((b, i) => { b.x -= 2; if(b.x < -10) bubbles.splice(i, 1); });
    if (frame % 200 === 0) createCloud();
    clouds.forEach((c, i) => { c.x -= c.speed; if (c.x < -c.w) clouds.splice(i, 1); });
    if (frame % 100 === 0) {
        const h = [77, 22][Math.floor(Math.random() * 2)];
        obstacles.push({ x: canvas.width, y: canvas.height - h, w: 40, h: h });
    }
    obstacles.forEach((ob, i) => {
        ob.x -= gameSpeed;
        if (checkCollision(medaka, ob)) { isGameOver = true; gameOverTime = Date.now(); }
        if (ob.x < -40) obstacles.splice(i, 1);
    });
    if (frame % 65 === 0) foods.push({ x: canvas.width, y: waterSurface + 20 + Math.random() * (canvas.height - waterSurface - 60), w: 20, h: 20 });
    foods.forEach((f, i) => {
        f.x -= gameSpeed;
        if (checkCollision(medaka, f, true)) { medaka.stamina = Math.min(100, medaka.stamina + 45); score += 50; foods.splice(i, 1); }
        else if (f.x < -20) foods.splice(i, 1);
    });
    if (frame % 850 === 0) {
        const img = document.createElement('img');
        img.src = ENEMY_BASE64;
        img.className = 'gif-overlay';
        container.appendChild(img);
        enemies.push({ x: canvas.width, y: waterSurface + 20 + Math.random() * (canvas.height - waterSurface - 80), w: 120, h: 60, dom: img });
    }
    enemies.forEach((en, i) => {
        en.x -= (gameSpeed + 0.5);
        en.dom.style.left = (en.x * scale) + "px";
        en.dom.style.top = (en.y * scale) + "px";
        en.dom.style.width = (en.w * scale) + "px";
        en.dom.style.height = (en.h * scale) + "px";
        if (checkCollision(medaka, en)) { isGameOver = true; gameOverTime = Date.now(); }
        if (en.x < -120) { container.removeChild(en.dom); enemies.splice(i, 1); }
    });

    if (isGameOver) {
        if (Math.floor(score) > highScore) { highScore = Math.floor(score); localStorage.setItem("medakaHighScore", highScore); }
        medakaDom.style.display = "none";
        enemies.forEach(en => en.dom.style.display = "none");
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // 背景描画
    const skyGrad = ctx.createLinearGradient(0, 0, 0, waterSurface);
    skyGrad.addColorStop(0, "#87ceeb"); skyGrad.addColorStop(1, "#b3e5fc");
    ctx.fillStyle = skyGrad; ctx.fillRect(0, 0, canvas.width, waterSurface);
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    clouds.forEach(c => { ctx.beginPath(); ctx.ellipse(c.x, c.y, c.w/2, c.h/2, 0, 0, Math.PI*2); ctx.fill(); });
    const waterGrad = ctx.createLinearGradient(0, waterSurface, 0, canvas.height);
    waterGrad.addColorStop(0, "#4fc3f7"); waterGrad.addColorStop(1, "#0288d1");
    ctx.fillStyle = waterGrad; ctx.fillRect(0, waterSurface, canvas.width, canvas.height - waterSurface);

    // 波
    ctx.strokeStyle = "rgba(255,255,255,0.9)"; ctx.lineWidth = 2; ctx.beginPath();
    for (let x = 0; x <= canvas.width; x += 10) {
        const y = waterSurface + Math.sin((x + frame*2) * 0.05) * 3;
        if (x === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();

    ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
    bubbles.forEach(b => { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill(); });
    ctx.fillStyle = "#1b5e20";
    obstacles.forEach(ob => ctx.fillRect(ob.x, ob.y, ob.w, ob.h));
    ctx.fillStyle = "#ff5252";
    foods.forEach(f => { ctx.beginPath(); ctx.arc(f.x + 10, f.y + 10, 8, 0, Math.PI*2); ctx.fill(); });

    // UI
    ctx.fillStyle = "#01579b"; ctx.font = "bold 16px sans-serif"; ctx.textAlign = "left";
    ctx.fillText(`SCORE: ${Math.floor(score)}`, 20, 30);
    ctx.font = "12px sans-serif"; ctx.fillText(`HIGH: ${highScore}`, 20, 45);
    ctx.fillStyle = "rgba(255,255,255,0.3)"; ctx.fillRect(20, 55, 100, 12);
    ctx.fillStyle = medaka.stamina > 25 ? "#66bb6a" : "#ef5350"; ctx.fillRect(20, 55, medaka.stamina, 12);
    ctx.strokeStyle = "#01579b"; ctx.strokeRect(20, 55, 100, 12);

    if (isGameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "white"; ctx.font = "bold 30px sans-serif"; ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
        ctx.font = "18px sans-serif"; ctx.fillText(Date.now()-gameOverTime<1000?"...":"タップでリスタート", canvas.width/2, canvas.height/2 + 50);
    }
}

function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
   
