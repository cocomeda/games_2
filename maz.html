
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>滑らか一本道迷路 評価テスト</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
body {
    margin: 0;
    font-family: Arial, sans-serif;
    background: #f0f2f5;
    text-align: center;
    touch-action: none;
}

#info {
    padding: 10px;
    font-size: 1.2em;
}

/* ===== フィールド ===== */
#field {
    position: relative;
    width: 100vw;
    height: 55vh;
    background: #222;
    overflow: hidden;
}

canvas {
    position: absolute;
    inset: 0;
}

#player {
    position: absolute;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: black;
    z-index: 5;
}

#goal {
    position: absolute;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background: #4caf50;
    z-index: 5;
}

/* ===== 結果表示 ===== */
#fieldResult {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.75);
    color: white;
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    font-size: 2.2em;
    font-weight: bold;
    z-index: 20;
}

/* ===== 操作エリア ===== */
#controller {
    height: 25vh;
    margin: 10px;
    border: 3px solid #333;
    border-radius: 15px;
    background: #fafafa;
    position: relative;
}

#startOverlay {
    position: absolute;
    inset: 0;
    background: rgba(0,0,0,0.75);
    color: white;
    font-size: 3em;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    cursor: pointer;
}

#stick {
    position: absolute;
    width: 30px;
    height: 30px;
    border-radius: 50%;
    background: #2196f3;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}
</style>
</head>

<body>

<div id="info">
    時間: <span id="time">0.00</span> 秒
</div>

<div id="field">
    <canvas id="maze"></canvas>
    <div id="player"></div>
    <div id="goal"></div>
    <div id="fieldResult"></div>
</div>

<div id="controller">
    <div id="startOverlay">START</div>
    <div id="stick"></div>
</div>

<script>
/* ===== 設定 ===== */
const SPEED = 3.0;
const PLAYER_SIZE = 20;
const PLAYER_R = PLAYER_SIZE / 2;
const PATH_RADIUS = PLAYER_R * 2.5;
const POINTS = 6;
const GOAL_SIZE = 30;

/* ===== 状態 ===== */
const canvas = document.getElementById("maze");
const ctx = canvas.getContext("2d");
const field = document.getElementById("field");
const player = document.getElementById("player");
const goal = document.getElementById("goal");
const controller = document.getElementById("controller");
const startOverlay = document.getElementById("startOverlay");
const fieldResult = document.getElementById("fieldResult");
const timeEl = document.getElementById("time");

let path = [];
let lastX = null, lastY = null;
let active = false;
let startTime, timerInterval;
let pathLength = 0, tremorSum = 0;
let prevPX = null, prevPY = null;
let prevDX = null, prevDY = null;

/* ===== スタート ===== */
startOverlay.addEventListener("pointerdown", () => {
    startOverlay.style.display = "none";
    fieldResult.style.display = "none";
    startGame();
});

function startGame() {
    resize();
    generatePath();
    drawPath();

    player.style.left = (path[0].x - PLAYER_R) + "px";
    player.style.top  = (path[0].y - PLAYER_R) + "px";

    // ゴール設置
    goal.style.left = (path[path.length-1].x - GOAL_SIZE/2) + "px";
    goal.style.top  = (path[path.length-1].y - GOAL_SIZE/2) + "px";

    active = true;
    pathLength = 0;
    tremorSum = 0;
    prevPX = path[0].x;
    prevPY = path[0].y;
    prevDX = null;
    prevDY = null;

    clearInterval(timerInterval);
    startTime = performance.now();
    timerInterval = setInterval(updateTime, 10);
}

/* ===== タイマー ===== */
function updateTime() {
    timeEl.textContent = ((performance.now() - startTime) / 1000).toFixed(2);
}

/* ===== パス生成 ===== */
function generatePath() {
    const w = canvas.width;
    const h = canvas.height;
    path = [];
    for (let i = 0; i < POINTS; i++) {
        path.push({
            x: (i / (POINTS - 1)) * w,
            y: h * (0.2 + Math.random() * 0.6)
        });
    }
}

/* ===== 描画 ===== */
function drawPath() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.lineWidth = PATH_RADIUS*2;
    ctx.lineCap = "round";
    ctx.strokeStyle = "#eee";

    ctx.beginPath();
    ctx.moveTo(path[0].x, path[0].y);
    for (let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
    ctx.stroke();
}

/* ===== 操作 ===== */
controller.addEventListener("pointerdown", e => {
    if (!active) return;
    lastX = e.clientX;
    lastY = e.clientY;
});

controller.addEventListener("pointermove", e => {
    if (!active || lastX === null) return;

    const dx = (e.clientX - lastX) * SPEED;
    const dy = (e.clientY - lastY) * SPEED;

    movePlayer(dx, dy);
    moveStick(e);

    lastX = e.clientX;
    lastY = e.clientY;
});

controller.addEventListener("pointerup", () => lastX = lastY = null);
controller.addEventListener("pointerleave", () => lastX = lastY = null);

function moveStick(e) {
    const r = controller.getBoundingClientRect();
    stick.style.left = (e.clientX - r.left) + "px";
    stick.style.top  = (e.clientY - r.top) + "px";
}

/* ===== 移動 ===== */
function movePlayer(dx, dy) {
    const p = player.getBoundingClientRect();
    const f = field.getBoundingClientRect();

    const cx = p.left - f.left + PLAYER_R + dx;
    const cy = p.top - f.top + PLAYER_R + dy;

    player.style.left = (cx - PLAYER_R) + "px";
    player.style.top  = (cy - PLAYER_R) + "px";

    accumulatePath(cx, cy);
    checkCollision(cx, cy);
    checkGoal(cx, cy);
}

/* ===== 距離・震え計算 ===== */
function accumulatePath(cx, cy) {
    const dx = cx - prevPX;
    const dy = cy - prevPY;

    pathLength += Math.hypot(dx, dy);

    if (prevDX !== null) {
        const dot = dx*prevDX + dy*prevDY;
        const mag1 = Math.hypot(dx, dy);
        const mag2 = Math.hypot(prevDX, prevDY);
        if (mag1>0 && mag2>0) {
            const cos = dot / (mag1*mag2);
            const angle = Math.acos(Math.max(-1, Math.min(1, cos)));
            tremorSum += angle;
        }
    }

    prevDX = dx;
    prevDY = dy;
    prevPX = cx;
    prevPY = cy;
}

/* ===== 判定 ===== */
function checkCollision(cx, cy) {
    let minDist = Infinity;
    for (let i=0; i<path.length-1; i++) {
        const d = pointToSegment(cx, cy, path[i], path[i+1]);
        minDist = Math.min(minDist, d);
    }
    if (minDist > PATH_RADIUS - PLAYER_R) gameOver();
}

/* ===== ゴール判定 ===== */
function checkGoal(cx, cy) {
    const gRect = goal.getBoundingClientRect();
    const fRect = field.getBoundingClientRect();
    const gx = gRect.left - fRect.left + GOAL_SIZE/2;
    const gy = gRect.top - fRect.top + GOAL_SIZE/2;

    if (Math.hypot(cx - gx, cy - gy) < PLAYER_R + GOAL_SIZE/2) gameClear();
}

/* 点と線分の距離 */
function pointToSegment(px, py, a, b) {
    const vx = b.x - a.x;
    const vy = b.y - a.y;
    const wx = px - a.x;
    const wy = py - a.y;

    const c1 = vx*wx + vy*wy;
    if (c1 <=0) return Math.hypot(px - a.x, py - a.y);
    const c2 = vx*vx + vy*vy;
    if (c2 <= c1) return Math.hypot(px - b.x, py - b.y);
    const t = c1 / c2;
    const ix = a.x + t*vx;
    const iy = a.y + t*vy;
    return Math.hypot(px - ix, py - iy);
}

/* ===== ゲームオーバー ===== */
function gameOver() {
    active = false;
    clearInterval(timerInterval);
    fieldResult.innerHTML = `<div style="font-size:3em; margin-bottom:20px">ゲームオーバー</div>
                              <div style="font-size:0.5em; margin-top:20px; opacity:0.7">タップで再スタート</div>`;
    fieldResult.style.display = "flex";
    startOverlay.style.display = "flex";
    startOverlay.textContent = "RESTART";
}

/* ===== クリア ===== */
function gameClear() {
    active = false;
    clearInterval(timerInterval);

    const totalOptimal = path.reduce((s,p,i)=>i>0?s+Math.hypot(p.x-path[i-1].x, p.y-path[i-1].y):0,0);
    const adjustedOptimal = totalOptimal - GOAL_SIZE/2; // ゴール半径を引く
    const totalTime = (performance.now() - startTime)/1000;
    const avgSpeed = totalOptimal / totalTime;
    const distanceRatio = pathLength / adjustedOptimal;

    fieldResult.innerHTML = `
        <div style="font-size:0.7em; opacity:0.8">クリア！ 総合指数</div>
        <div style="font-size:3.5em; margin-bottom:20px">
            ${(avgSpeed/distanceRatio).toFixed(2)}
        </div>
        <div>平均速度 ${avgSpeed.toFixed(2)}</div>
        <div>距離比 ${distanceRatio.toFixed(2)}</div>
        <div style="margin-top:15px; font-size:0.7em; opacity:0.8">
            操作安定性（震え） ${tremorSum.toFixed(2)}
        </div>
        <div style="font-size:0.5em; margin-top:20px; opacity:0.7">
            タップで再スタート
        </div>
    `;
    fieldResult.style.display = "flex";
    startOverlay.style.display = "flex";
    startOverlay.textContent = "RESTART";
}

/* ===== リサイズ ===== */
function resize() {
    canvas.width = field.clientWidth;
    canvas.height = field.clientHeight;
}
window.addEventListener("resize", resize);
</script>

</body>
  </html>
