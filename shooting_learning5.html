<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Monster Training - RNN Memory</title>
<style>
    body { margin:0; background:#05050a; overflow:hidden; color:#00ffcc; font-family:monospace; }
    canvas { display:block; }
    .ui { position:absolute; top:20px; left:20px; background:rgba(0,0,0,0.85); padding:15px; border-radius:8px; border:1px solid #00ffcc; width:280px; pointer-events:none; z-index:100; }
    .ui * { pointer-events: auto; }
    .stat { display:flex; justify-content:space-between; margin:8px 0; font-size:14px; }
    .control-group { margin-top: 15px; border-top: 1px solid #333; padding-top: 10px; }
    input[type="range"] { width: 100%; cursor: pointer; accent-color: #ff4444; }
    .btn { background:#002211; color:#00ffcc; border:1px solid #00ffcc; padding:10px; cursor:pointer; width:100%; margin-top:5px; font-weight:bold; font-size: 12px; }
    .btn:hover { background:#00ffcc; color:#002211; }
    .load-btn { background:#221100; color:#ffaa00; border:1px solid #ffaa00; }
    .load-btn:hover { background:#ffaa00; color:#221100; }
    b { font-size: 1.1em; text-shadow: 0 0 5px #00ffcc; color: #fff; }
    #fileInput { display: none; }
</style>
</head>
<body>

<div class="ui">
    <b>ARENA: RNN MEMORY UNIT</b>
    <hr style="border:0; border-top:1px solid #333;">
    <div class="stat">Pop: <span id="pop">0</span></div>
    <div class="stat">Max Age: <span id="maxAge">0</span></div>
    
    <div class="control-group">
        <label>弾丸の量: <span id="rateVal">8</span>%</label>
        <input type="range" id="bulletRate" min="0" max="50" value="8">
    </div>

    <hr style="border:0; border-top:1px solid #333;">
    <button class="btn load-btn" onclick="document.getElementById('fileInput').click()">LOAD BRAIN (.json)</button>
    <input type="file" id="fileInput" accept=".json" onchange="loadBrain(event)">
    
    <button class="btn" onclick="downloadBrain()">SAVE BRAIN (.json)</button>
    <p style="font-size:10px; color:#888; margin-top:5px;">※RNNにより、隠れ状態（記憶）を保持します</p>
</div>

<canvas id="sim"></canvas>

<script>
const canvas = document.getElementById('sim');
const ctx = canvas.getContext('2d');
let monsters = [];
let bullets = [];
let foods = [];
let obstacles = [];
let particles = [];
let maxAge = 0;
let frameCount = 0;

const rateSlider = document.getElementById('bulletRate');
const rateLabel = document.getElementById('rateVal');

// --- RNN Brain Class (記憶力の実装) ---
class Brain {
    constructor(weights = null) {
        this.inputSize = 14; 
        this.hiddenSize = 16; // このhidden層の値を次のフレームに引き継ぐ
        this.outputSize = 2;

        if (weights) {
            this.wInput = weights.wInput;   // 入力 -> 隠れ層
            this.wRecurrent = weights.wRecurrent; // 前回の隠れ層 -> 今回の隠れ層 (記憶)
            this.wOutput = weights.wOutput; // 隠れ層 -> 出力
        } else {
            const rnd = () => Math.random() * 2 - 1;
            this.wInput = Array.from({length: this.inputSize * this.hiddenSize}, rnd);
            this.wRecurrent = Array.from({length: this.hiddenSize * this.hiddenSize}, rnd);
            this.wOutput = Array.from({length: this.hiddenSize * this.outputSize}, rnd);
        }
    }

    predict(inputs, lastHidden) {
        let nextHidden = new Array(this.hiddenSize).fill(0);
        
        for(let i=0; i<this.hiddenSize; i++) {
            // 現在の入力の影響
            for(let j=0; j<this.inputSize; j++) {
                nextHidden[i] += inputs[j] * this.wInput[i * this.inputSize + j];
            }
            // 過去の記憶（前回のHidden層）の影響
            for(let j=0; j<this.hiddenSize; j++) {
                nextHidden[i] += lastHidden[j] * this.wRecurrent[i * this.hiddenSize + j];
            }
            nextHidden[i] = Math.tanh(nextHidden[i]); // 活性化
        }

        let outputs = [0, 0];
        for(let i=0; i<this.outputSize; i++) {
            for(let j=0; j<this.hiddenSize; j++) {
                outputs[i] += nextHidden[j] * this.wOutput[i * this.hiddenSize + j];
            }
            outputs[i] = Math.tanh(outputs[i]);
        }
        return { outputs, hidden: nextHidden };
    }

    mutate() {
        const m = (w) => (Math.random() < 0.1 ? w + (Math.random() * 2 - 1) * 0.3 : w);
        return new Brain({
            wInput: this.wInput.map(m),
            wRecurrent: this.wRecurrent.map(m),
            wOutput: this.wOutput.map(m)
        });
    }
}

// --- 共通ロジック (Particle, Obstacle, Bullet, Food) ---
class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color; this.size = Math.random() * 3 + 1;
        this.vx = (Math.random() - 0.5) * 8; this.vy = (Math.random() - 0.5) * 8; this.life = 1.0;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life -= 0.04; return this.life > 0; }
    draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life; ctx.fillRect(this.x, this.y, this.size, this.size); ctx.globalAlpha = 1; }
}
function createExplosion(x, y, color, count = 10) { for(let i=0; i<count; i++) particles.push(new Particle(x, y, color)); }

class Obstacle {
    constructor(x, y) { this.x = x; this.y = y; this.w = 80; this.h = 30; this.hp = 50; }
    draw() { ctx.fillStyle = "#282d3c"; ctx.strokeStyle = "#00ffcc"; ctx.lineWidth = 2; ctx.fillRect(this.x, this.y, this.w, this.h); ctx.strokeRect(this.x, this.y, this.w, this.h); }
}

class Monster {
    constructor(x, y, brain = null) {
        this.x = x; this.y = y; this.angle = Math.random() * Math.PI * 2;
        this.energy = 100; this.age = 0; this.eatBCount = 0;
        this.brain = brain || new Brain();
        // 記憶の初期化
        this.hiddenState = new Array(16).fill(0);
    }

    getSensors() {
        const nB = this.getNearest(bullets, 600);
        const nF = this.getNearest(foods, 600);
        const nM = this.getNearest(monsters.filter(m => m !== this), 400);
        const nO = this.getNearestObs(600);
        return [nB.dist, nB.angle, nF.dist, nF.angle, nM.dist, nM.angle, nO.dist, nO.angle, this.energy/100, Math.cos(this.angle), Math.sin(this.angle), 1, 0, 0];
    }

    getNearest(list, maxRange) {
        let found = list.reduce((prev, curr) => {
            let d = Math.hypot(curr.x - this.x, curr.y - this.y);
            return d < prev.d ? {d: d, obj: curr} : prev;
        }, {d: maxRange, obj: null});
        if (found.obj) {
            let ang = Math.atan2(found.obj.y - this.y, found.obj.x - this.x) - this.angle;
            return { dist: found.d / maxRange, angle: Math.sin(ang) };
        }
        return { dist: 1, angle: 0 };
    }

    getNearestObs(maxRange) {
        let found = obstacles.reduce((prev, curr) => {
            let cx = curr.x + curr.w/2; let cy = curr.y + curr.h/2;
            let d = Math.hypot(cx - this.x, cy - this.y);
            return d < prev.d ? {d: d, obj: curr} : prev;
        }, {d: maxRange, obj: null});
        if (found.obj) {
            let cx = found.obj.x + found.obj.w/2; let cy = found.obj.y + found.obj.h/2;
            let ang = Math.atan2(cy - this.y, cx - this.x) - this.angle;
            return { dist: found.d / maxRange, angle: Math.sin(ang) };
        }
        return { dist: 1, angle: 0 };
    }

    update() {
        this.age++;
        const { outputs, hidden } = this.brain.predict(this.getSensors(), this.hiddenState);
        this.hiddenState = hidden; // 記憶を更新
        const [turn, accel] = outputs;

        if (monsters.length > 1) {
            const baseMetabolism = 0.08;
            const speedVal = (accel + 1) * 2.5;
            this.energy -= (baseMetabolism + (speedVal * 0.04) + (Math.abs(turn) * 0.03));
        }

        this.angle += turn * 0.15;
        const speed = (accel + 1) * 2.5;
        let nextX = this.x + Math.cos(this.angle) * speed;
        let nextY = this.y + Math.sin(this.angle) * speed;

        let canMove = true;
        if (nextX < 15 || nextX > canvas.width - 15 || nextY < 15 || nextY > canvas.height - 15) canMove = false;
        for(let obs of obstacles) { if (nextX > obs.x && nextX < obs.x + obs.w && nextY > obs.y && nextY < obs.y + obs.h) { canMove = false; break; } }
        if(canMove) { this.x = nextX; this.y = nextY; }
        return this.energy > 0;
    }

    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.fillStyle = (monsters.length === 1) ? '#ff00ff' : '#00ffcc';
        ctx.beginPath(); ctx.moveTo(12, 0); ctx.lineTo(-8, -7); ctx.lineTo(-8, 7); ctx.fill();
        ctx.restore();
    }
}

class Bullet {
    constructor() { this.x = Math.random() * canvas.width; this.y = canvas.height + 10; this.speed = [12, 18, 27][Math.floor(Math.random()*3)]; }
    update() {
        this.y -= this.speed;
        for(let i=obstacles.length-1; i>=0; i--) {
            let o = obstacles[i];
            if(this.x > o.x && this.x < o.x + o.w && this.y > o.y && this.y < o.y + o.h) {
                o.hp--; createExplosion(this.x, this.y, "#ffcc00", 6);
                if(o.hp <= 0) obstacles.splice(i, 1); return false;
            }
        }
        return this.y > -20;
    }
    draw() { ctx.fillStyle = '#ff4444'; ctx.fillRect(this.x, this.y, 3, 15); }
}

class Food {
    constructor(type) { this.x = 40 + Math.random() * (canvas.width-80); this.y = 40 + Math.random() * (canvas.height-80); this.type = type; }
    draw() { ctx.fillStyle = this.type === 'A' ? '#0f0' : '#08f'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, 7); ctx.fill(); }
}

// --- システム管理 ---
function init() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    monsters = []; bullets = []; foods = []; obstacles = []; particles = [];
    for(let i=0; i<15; i++) monsters.push(new Monster(canvas.width/2, canvas.height/2));
    for(let i=0; i<20; i++) obstacles.push(new Obstacle(Math.random()*(canvas.width-150)+75, Math.random()*(canvas.height-250)+100));
}

function loop() {
    frameCount++;
    ctx.fillStyle = '#05050a'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    const spawnRate = parseInt(rateSlider.value) / 100;
    rateLabel.innerText = rateSlider.value;

    if (frameCount % 300 === 0 && obstacles.length < 30) obstacles.push(new Obstacle(Math.random()*(canvas.width-150)+75, Math.random()*(canvas.height-250)+100));
    
    
    
    
    if (monsters.length <= 30 && foods.length < 30) for(let i=0; i<15; i++) foods.push(new Food(Math.random() > 0.5 ? 'A' : 'B'));
    if (Math.random() < spawnRate) bullets.push(new Bullet());
    if (Math.random() < 0.05) foods.push(new Food('A'));

    obstacles.forEach(o => o.draw());
    bullets = bullets.filter(b => { b.draw(); return b.update(); });
    foods.forEach(f => f.draw());
    particles = particles.filter(p => { p.draw(); return p.update(); });

    for (let i = monsters.length - 1; i >= 0; i--) {
        const m = monsters[i];
        if (!m.update()) { monsters.splice(i, 1); continue; }
        m.draw();
        bullets.forEach((b, bi) => { if (Math.hypot(m.x - b.x, m.y - b.y) < 16) { createExplosion(m.x, m.y, "#f00", 20); monsters.splice(i, 1); bullets.splice(bi, 1); } });
        foods.forEach((f, fi) => { if (Math.hypot(m.x - f.x, m.y - f.y) < 18) { m.energy = Math.min(100, m.energy + 40); if (f.type === 'A' || (f.type === 'B' && ++m.eatBCount >= 3)) { monsters.push(new Monster(m.x, m.y, m.brain.mutate())); m.eatBCount = 0; } foods.splice(fi, 1); } });
    }

    document.getElementById('pop').innerText = monsters.length;
    if(monsters.length > 0) { let currentBest = Math.max(...monsters.map(m => m.age)); if(currentBest > maxAge) maxAge = currentBest; }
    document.getElementById('maxAge').innerText = maxAge;
    requestAnimationFrame(loop);
}

function downloadBrain() {
    if (monsters.length === 0) return;
    const best = monsters.reduce((p, c) => p.age > c.age ? p : c);
    const blob = new Blob([JSON.stringify({wInput: best.brain.wInput, wRecurrent: best.brain.wRecurrent, wOutput: best.brain.wOutput})], {type: "application/json"});
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "rnn_monster_brain.json"; a.click();
}

function loadBrain(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const d = JSON.parse(e.target.result);
            monsters.forEach(m => { m.brain = new Brain({ wInput: [...d.wInput], wRecurrent: [...d.wRecurrent], wOutput: [...d.wOutput] }); m.hiddenState.fill(0); });
            alert("RNN知能を読み込みました。");
        } catch (err) { alert("形式エラー"); }
    };
    reader.readAsText(file);
}

window.addEventListener('resize', init);
init(); loop();
</script>
</body>
</html>
