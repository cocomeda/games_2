<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Survival of the Smartest: Knowledge Inheritance</title>
    <style>
        body { margin: 0; background: #020202; overflow: hidden; color: white; font-family: 'Consolas', monospace; }
        canvas { display: block; }
        .stats { position: absolute; top: 15px; left: 15px; background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px; border: 1px solid #444; min-width: 200px; box-shadow: 0 0 15px rgba(0,0,0,0.5); }
        .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 10px; }
        .c-1 { color: #ff3333; } .c-2 { color: #3333ff; } .c-3 { color: #ffff33; } .c-4 { color: #ff33ff; }
        .val { font-weight: bold; float: right; }
        #log { color: #00ffcc; font-size: 10px; margin-top: 10px; display: block; }
    </style>
</head>
<body>
    <div class="stats">
        <b>EVOLUTION: INHERITANCE</b><hr style="border:0; border-top:1px solid #444">
        草食 (継承型): <span id="hCount" class="val">0</span><br>
        <div class="grid">
            <span class="c-1">RED: <span id="cnt1" class="val">0</span></span>
            <span class="c-2">BLUE: <span id="cnt2" class="val">0</span></span>
            <span class="c-3">YEL: <span id="cnt3" class="val">0</span></span>
            <span class="c-4">PUR: <span id="cnt4" class="val">0</span></span>
        </div>
        <hr style="border:0; border-top:1px solid #444">
        <span id="log">Awaiting next generation...</span>
    </div>
    <canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const TYPES = [
    { id: 1, name: 'RED', color: '#ff3333' },
    { id: 2, name: 'BLUE', color: '#3333ff' },
    { id: 3, name: 'YEL', color: '#ffff33' },
    { id: 4, name: 'PUR', color: '#ff33ff' }
];

let creatures = [];
const MAX_TOTAL = 350;

// --- 知識継承用の変数 ---
let eliteHerbBrain = null;

class Brain {
    constructor(weights = null) {
        if (weights) {
            // 継承時に少しだけ変異を加える (0.15の確率で値を変動)
            this.w1 = weights.w1.map(v => Math.random() < 0.15 ? v + (Math.random() - 0.5) * 0.4 : v);
            this.w2 = weights.w2.map(v => Math.random() < 0.15 ? v + (Math.random() - 0.5) * 0.4 : v);
        } else {
            this.w1 = Array.from({length: 35}, () => Math.random() * 2 - 1);
            this.w2 = Array.from({length: 10}, () => Math.random() * 2 - 1);
        }
    }
    predict(inputs) {
        let hidden = [];
        for(let i=0; i<5; i++) {
            let sum = 0;
            for(let j=0; j<7; j++) sum += inputs[j] * this.w1[i * 7 + j];
            hidden.push(Math.tanh(sum));
        }
        let outputs = [];
        for(let i=0; i<2; i++) {
            let sum = 0;
            for(let j=0; j<5; j++) sum += hidden[j] * this.w2[i * 5 + j];
            outputs.push(Math.tanh(sum));
        }
        return outputs;
    }
}

class Creature {
    constructor(x, y, type, config = null, brain = null) {
        this.x = x; this.y = y; this.type = type;
        this.config = config;
        this.energy = 200;
        this.angle = Math.random() * Math.PI * 2;
        this.brain = (brain instanceof Brain) ? brain : new Brain(brain);
        this.baseSpeed = (type === 'herb') ? 5.5 : 3.6; 
    }

    update() {
        let nTarget = this.getNearest(creatures.filter(c => 
            (this.type === 'carn' && c.type === 'herb') || 
            (this.type === 'herb' && c.type === 'carn')
        ));

        let inputs = [
            nTarget ? nTarget.dist / 350 : 1,
            nTarget ? Math.atan2(nTarget.y - this.y, nTarget.x - this.x) - this.angle : 0,
            this.energy / 400,
            Math.sin(this.angle),
            Math.cos(this.angle),
            Math.random() * 0.1,
            this.type === 'herb' ? 1 : 0
        ];

        let [turn, accel] = this.brain.predict(inputs);
        this.angle += turn * 0.25;
        let speed = this.baseSpeed * Math.abs(accel);
        this.x += Math.cos(this.angle) * speed;
        this.y += Math.sin(this.angle) * speed;

        if (this.x < 0) this.x = canvas.width; else if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height; else if (this.y > canvas.height) this.y = 0;

        if (this.type === 'carn') {
            this.energy -= (0.18 + speed * 0.25);
            const sameKindCount = creatures.filter(c => c.config && c.config.id === this.config.id).length;
            if (this.energy <= 0) {
                if (sameKindCount > 1) return false;
                this.energy = 15; 
            }
            this.checkHunt();
        }
        return true;
    }

    getNearest(list) {
        let nearest = null, minDist = 400;
        for (let item of list) {
            let d = Math.hypot(this.x - item.x, this.y - item.y);
            if (d < minDist) { minDist = d; nearest = {x: item.x, y: item.y, dist: d}; }
        }
        return nearest;
    }

    checkHunt() {
        for (let i = creatures.length - 1; i >= 0; i--) {
            let target = creatures[i];
            if (target.type === 'herb' && Math.hypot(this.x - target.x, this.y - target.y) < 18) {
                this.energy += 120;
                
                // 最後の一匹が食べられる前に、その脳を記録する
                if (creatures.filter(c => c.type === 'herb').length === 1) {
                    eliteHerbBrain = {
                        w1: [...target.brain.w1],
                        w2: [...target.brain.w2]
                    };
                }
                
                creatures.splice(i, 1); 
                if (creatures.length < MAX_TOTAL) {
                    let baby = new Creature(this.x, this.y, 'carn', this.config, new Brain(this.brain));
                    baby.energy = 160;
                    creatures.push(baby);
                }
                break;
            }
        }
    }

    draw() {
        ctx.fillStyle = this.type === 'herb' ? "#fff" : this.config.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.type === 'herb' ? 3.5 : 7, 0, Math.PI * 2);
        ctx.fill();
        // 視線方向の表示
        ctx.strokeStyle = "rgba(0,0,0,0.5)";
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(this.angle)*5, this.y + Math.sin(this.angle)*5);
        ctx.stroke();
    }
}

function addHerbs(num, useElite = false) {
    for(let i=0; i<num; i++) {
        // エリート脳があればそれを使い、なければ新規
        let brain = (useElite && eliteHerbBrain) ? new Brain(eliteHerbBrain) : null;
        creatures.push(new Creature(Math.random()*canvas.width, Math.random()*canvas.height, 'herb', null, brain));
    }
}

function init() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    creatures = [];
    addHerbs(50, false);
    TYPES.forEach(t => creatures.push(new Creature(Math.random()*canvas.width, Math.random()*canvas.height, 'carn', t)));
}

function animate() {
    ctx.fillStyle = '#020202'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    let counts = { herb: 0, 1: 0, 2: 0, 3: 0, 4: 0 };

    for (let i = creatures.length - 1; i >= 0; i--) {
        if (!creatures[i].update()) {
            creatures.splice(i, 1);
        } else {
            creatures[i].draw();
            if (creatures[i].type === 'herb') counts.herb++;
            else counts[creatures[i].config.id]++;
        }
    }

    if (counts.herb === 0) {
        addHerbs(50, true); // エリートの知識を継承して復活
        document.getElementById('log').innerText = "NEW GENERATION: ELITE DNA REPLICATED";
    }

    document.getElementById('hCount').innerText = counts.herb;
    document.getElementById('cnt1').innerText = counts[1];
    document.getElementById('cnt2').innerText = counts[2];
    document.getElementById('cnt3').innerText = counts[3];
    document.getElementById('cnt4').innerText = counts[4];

    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

init(); animate();
</script>
</body>
</html>
