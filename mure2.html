<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Eco-Evolution v6.2 - Flocking Analysis</title>
<style>
    body { margin:0; background:#050505; overflow:hidden; color:#0f0; font-family:'Consolas',monospace; }
    canvas { display:block; }
    .ui { 
        position:absolute; top:15px; left:15px; 
        background:rgba(0, 0, 0, 0.4); padding:15px; border-radius:8px; 
        border:1px solid rgba(0, 255, 204, 0.2); min-width:280px; pointer-events: none; z-index: 100;
    }
    .controls { pointer-events: auto; }
    .red { color: #ff4444; } .white { color: #ffffff; } .cyan { color: #00ffcc; }
    hr { border:0; border-top:1px solid rgba(255,255,255,0.1); margin:10px 0; }
    .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top:10px; }
    button { background:rgba(40,40,40,0.7); color:#fff; border:1px solid #555; padding:5px; cursor:pointer; font-size:11px; }
    #log { font-size:11px; color:#888; height: 1.2em; margin-top:5px; }
    #fileInput { display: none; }
</style>
</head>
<body>
<div class="ui">
    <b>ECO-EVOLUTION v6.2</b><hr>
    <div style="display:flex; justify-content:space-between;">
        <span class="white">PREY: <span id="hCnt">0</span></span>
        <span class="red">HUNTER: <span id="pCnt">0</span></span>
    </div>
    <span class="cyan">MEAT: <span id="mCnt">0</span></span>
    <hr>
    <div class="controls">
        <div class="btn-grid">
            <button onclick="saveBrain('prey')">草食保存</button>
            <button onclick="saveBrain('hunter')">肉食保存</button>
            <button onclick="triggerLoad('prey')">草食ロード</button>
            <button onclick="triggerLoad('hunter')">肉食ロード</button>
        </div>
    </div>
    <div id="log">Flocking Evolution ACTIVE</div>
</div>
<input type="file" id="fileInput" accept=".json" onchange="handleFileLoad()">
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let creatures = [];
let meats = [];
let loadTarget = 'prey';

/* ======================
   Brain
====================== */
class Brain {
    constructor(weights = null) {
        this.inputSize = 12;
        this.hiddenSize = 16;
        if (weights) {
            this.w1 = new Float32Array(weights.w1).map(v => Math.random() < 0.12 ? v + (Math.random()-0.5)*0.3 : v);
            this.w2 = new Float32Array(weights.w2).map(v => Math.random() < 0.12 ? v + (Math.random()-0.5)*0.3 : v);
        } else {
            this.w1 = Float32Array.from({length: this.inputSize * this.hiddenSize}, () => Math.random() * 2 - 1);
            this.w2 = Float32Array.from({length: this.hiddenSize * 2}, () => Math.random() * 2 - 1);
        }
    }
    predict(inputs) {
        let h = new Float32Array(this.hiddenSize);
        for(let i=0; i<this.hiddenSize; i++) {
            let sum = 0;
            for(let j=0; j<this.inputSize; j++) sum += inputs[j] * this.w1[i * this.inputSize + j];
            h[i] = Math.tanh(sum);
        }
        let out = [0, 0];
        for(let i=0; i<2; i++) {
            let sum = 0;
            for(let j=0; j<this.hiddenSize; j++) sum += h[j] * this.w2[i * this.hiddenSize + j];
            out[i] = Math.tanh(sum);
        }
        return out;
    }
}

/* ======================
   Creature
====================== */
class Creature {
    constructor(x, y, type, brain = null) {
        this.x = x; this.y = y; this.type = type;
        this.energy = 100; 
        this.angle = Math.random() * Math.PI * 2;
        this.brain = (brain instanceof Brain) ? brain : new Brain(brain);
        this.speed = 0;
        this.justHunted = 0;
    }

    normalizeDist(d) { return 1 / (1 + d / 150); }

    update() {
        let inputs = [];
        let enemies = creatures.filter(c => c.type !== this.type);

        // 1-2. 最近敵
        let nearestE = null, minDistE = 2000;
        for(let e of enemies) {
            let d = Math.hypot(this.x - e.x, this.y - e.y);
            if(d < minDistE) { minDistE = d; nearestE = e; }
        }
        inputs.push(this.normalizeDist(minDistE),
            nearestE ? (Math.atan2(nearestE.y - this.y, nearestE.x - this.x) - this.angle) / Math.PI : 0);

        // 3-4. 味方重心
        let friends = creatures.filter(c => c.type === this.type && c !== this);
        let fAvgDx = 0, fAvgDy = 0, fCount = 0;
        friends.forEach(f => {
            let d = Math.hypot(f.x - this.x, f.y - this.y);
            if(d < 150) { fCount++; fAvgDx += (f.x - this.x); fAvgDy += (f.y - this.y); }
        });
        inputs.push(Math.min(fCount, 10) / 10,
            fCount > 0 ? (Math.atan2(fAvgDy, fAvgDx) - this.angle) / Math.PI : 0);

        // 5-6. 敵重心
        let eAvgDx = 0, eAvgDy = 0, eCount = 0;
        enemies.forEach(e => {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if(d < 150) { eCount++; eAvgDx += (e.x - this.x); eAvgDy += (e.y - this.y); }
        });
        inputs.push(Math.min(eCount, 10) / 10,
            eCount > 0 ? (Math.atan2(eAvgDy, eAvgDx) - this.angle) / Math.PI : 0);

        // 7-10. 自己状態
        inputs.push(this.energy / 100,
            Math.min(this.x, canvas.width-this.x, this.y, canvas.height-this.y) / 50);
        inputs.push(this.speed / 5, Math.sin(this.angle));

        // 11-12. 餌センサー（草食のみ）
        if (this.type === 'prey') {
            let nearestM = null, minDistM = 2000;
            for (let m of meats) {
                let d = Math.hypot(this.x - m.x, this.y - m.y);
                if (d < minDistM) { minDistM = d; nearestM = m; }
            }
            inputs.push(this.normalizeDist(minDistM),
                nearestM ? (Math.atan2(nearestM.y - this.y, nearestM.x - this.x) - this.angle) / Math.PI : 0);
        } else { inputs.push(0, 0); }

        // NN行動
        let [turn, accel] = this.brain.predict(inputs);
        this.angle += turn * 0.25;

        if(this.type === 'prey'){
            if(this.energy > 0){
                this.speed = 3.2 * Math.abs(accel);
            }else{
                this.speed = 0; // 草食は死なず停止
            }
        }else{
            this.speed = 3.5 * Math.abs(accel);
            if(this.justHunted > 0){
                this.speed *= 0.3;
                this.justHunted--;
            }
        }

        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;

        // 壁反射
        if(this.x <= 0 || this.x >= canvas.width) this.angle = Math.PI - this.angle;
        if(this.y <= 0 || this.y >= canvas.height) this.angle = -this.angle;
        this.x = Math.max(0, Math.min(canvas.width, this.x));
        this.y = Math.max(0, Math.min(canvas.height, this.y));

        const isLastHunter = (this.type === 'hunter' && creatures.filter(c => c.type === 'hunter').length <= 1);

        // エネルギー消費
        if (this.type === 'hunter') {
            const loss = 0.05 + (this.speed ** 2) * 0.01;
            if (!(isLastHunter && this.energy <= loss + 0.1)) this.energy -= loss;
            this.checkHunt();
            if(isLastHunter) this.energy = Math.max(this.energy, 1); // 最後のHUNTERは不死
        } else {
            this.energy -= 0.008;
            this.checkEatMeat();
        }

        // 草食は死なない、肉食のみ死亡
        if(this.type === 'prey') return true;
        return (this.energy > 0);
    }

    checkHunt() {
        if (this.energy > 90) return;
        for (let i = creatures.length - 1; i >= 0; i--) {
            let c = creatures[i];
            if (c.type === 'prey' && Math.hypot(this.x - c.x, this.y - c.y) < 10) {
                // 草食は消えず、肉食がエネルギー回復＋減速
                this.energy = 100;
                this.justHunted = 60;
                break;
            }
        }
    }

    checkEatMeat() {
        for (let i = meats.length - 1; i >= 0; i--) {
            let m = meats[i];
            if (Math.hypot(this.x - m.x, this.y - m.y) < 10) {
                meats.splice(i, 1);
                this.energy = 100;
                break;
            }
        }
    }

    draw() {
        ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
        ctx.fillStyle = this.type === 'prey' ? "#fff" : "#f44";
        ctx.beginPath();
        if(this.type === 'prey') ctx.arc(0, 0, 1.5, 0, Math.PI*2);
        else { ctx.moveTo(4,0); ctx.lineTo(-3,-2); ctx.lineTo(-3,2); ctx.closePath(); }
        ctx.fill(); ctx.restore();
    }
}

/* ======================
   Save / Load
====================== */
function saveBrain(type) {
    const list = creatures.filter(c => c.type === type); if (list.length === 0) return;
    const target = list[Math.floor(Math.random() * list.length)];
    const data = { type: type, w1: Array.from(target.brain.w1), w2: Array.from(target.brain.w2) };
    const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
    const a = document.createElement("a"); a.href = URL.createObjectURL(blob);
    a.download = `brain_v6.2_${type}.json`; a.click();
}
function triggerLoad(type) { loadTarget = type; document.getElementById('fileInput').click(); }
function handleFileLoad() {
    const file = document.getElementById('fileInput').files[0]; if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const data = JSON.parse(e.target.result);
            creatures.filter(c => c.type === loadTarget).forEach(c => c.brain = new Brain(data));
            document.getElementById('log').innerText = "Brain Loaded.";
        } catch(e) { document.getElementById('log').innerText = "Load Error."; }
    };
    reader.readAsText(file);
}

/* ======================
   Init
====================== */
function init() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    creatures = []; meats = [];
    for(let i=0; i<250; i++) creatures.push(new Creature(Math.random()*canvas.width, Math.random()*canvas.height, 'prey'));
    for(let i=0; i<12; i++) creatures.push(new Creature(Math.random()*canvas.width, Math.random()*canvas.height, 'hunter'));
}

/* ======================
   Animate
====================== */
function animate() {
    ctx.fillStyle = 'rgba(5,5,5,0.5)'; ctx.fillRect(0,0,canvas.width, canvas.height);

    let pL = creatures.filter(c => c.type === 'prey');
    let hL = creatures.filter(c => c.type === 'hunter');

    /* ★ ここが今回の追加ロジック ★
       草食が15以下になった瞬間、
       草食の餌（meat）をすべて草食に変換する
    */
    if (pL.length <= 15 && meats.length > 0) {
        while (meats.length > 0) {
            let m = meats.pop();
            const parent = pL[Math.floor(Math.random() * pL.length)];
            creatures.push(new Creature(
                m.x, m.y, 'prey',
                parent ? new Brain({w1: Array.from(parent.brain.w1), w2: Array.from(parent.brain.w2)}) : null
            ));
        }
        document.getElementById('log').innerText = "PREY REBORN";
    }

    for(let i = creatures.length-1; i >= 0; i--) {
        if(!creatures[i].update()) {
            if(creatures[i].type === 'hunter') meats.push({x: creatures[i].x, y: creatures[i].y});
            creatures.splice(i, 1);
        } else {
            creatures[i].draw();
        }
    }

    // 餌描画
    meats.forEach(m => {
        ctx.fillStyle = "#0fc";
        ctx.beginPath();
        ctx.arc(m.x, m.y, 1.2, 0, Math.PI*2);
        ctx.fill();
    });

    document.getElementById('hCnt').innerText = creatures.filter(c => c.type === 'prey').length;
    document.getElementById('pCnt').innerText = creatures.filter(c => c.type === 'hunter').length;
    document.getElementById('mCnt').innerText = meats.length;

    requestAnimationFrame(animate);
}

window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
init(); 
animate();
</script>
</body>
</html>
