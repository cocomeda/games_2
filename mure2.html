<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Evolution Swarm v6.2</title>
<style>
    body { margin:0; background:#05050a; color:#e0f2ff; font-family:system-ui, sans-serif; overflow:hidden; }
    canvas { display:block; }
    .ui {
        position:absolute; left:10px; top:10px; background:rgba(0,0,0,0.6);
        padding:10px; border-radius:8px; font-size:12px; line-height:1.4;
    }
    .ui button { margin:2px 0; }
    .badge { display:inline-block; padding:2px 6px; border-radius:6px; margin-right:4px; }
    .prey { background:#2dd4bf; color:#001a17; }
    .hunter { background:#fb7185; color:#220007; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
    <div><span class="badge prey">PREY</span>草食</div>
    <div><span class="badge hunter">HUNTER</span>肉食</div>
    <hr>
    <div id="stats"></div>
    <hr>
    <button id="save">NNを保存</button>
    <button id="load">NNを読み込み</button>
    <button id="reset">リセット</button>
</div>

<script>
// =========================
// 基本設定（v6.1のまま）
// =========================
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function resize(){ canvas.width=innerWidth; canvas.height=innerHeight; }
addEventListener('resize', resize); resize();

const W = ()=>canvas.width;
const H = ()=>canvas.height;

const PREY_COUNT = 80;
const HUNTER_COUNT = 6;

const MAX_SPEED_PREY = 2.2;
const MAX_SPEED_HUNTER = 3.0;

const FOV = 80;
const SEP_DIST = 16;

const ENERGY_MAX = 100;
const BASE_DECAY = 0.02;
const SPEED_COST = 0.02;

// =========================
// ユーティリティ
// =========================
function rand(a,b){ return a+Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function dist(ax,ay,bx,by){ return Math.hypot(ax-bx, ay-by); }

// =========================
// 超軽量 NN（保存/読込対応）
// =========================
class Brain{
    constructor(input=8, hidden=8, output=2, data=null){
        this.input=input; this.hidden=hidden; this.output=output;
        if(data){
            this.w1 = data.w1.map(r=>r.slice());
            this.w2 = data.w2.map(r=>r.slice());
        }else{
            this.w1 = Array.from({length:hidden},()=>Array.from({length:input},()=>rand(-1,1)));
            this.w2 = Array.from({length:output},()=>Array.from({length:hidden},()=>rand(-1,1)));
        }
    }
    clone(m=0.05){
        const b = new Brain(this.input,this.hidden,this.output,{w1:this.w1,w2:this.w2});
        for(let i=0;i<b.w1.length;i++) for(let j=0;j<b.w1[i].length;j++)
            if(Math.random()<0.2) b.w1[i][j]+=rand(-m,m);
        for(let i=0;i<b.w2.length;i++) for(let j=0;j<b.w2[i].length;j++)
            if(Math.random()<0.2) b.w2[i][j]+=rand(-m,m);
        return b;
    }
    act(x){ return Math.tanh(x); }
    predict(inputs){
        const h = this.w1.map(row => this.act(row.reduce((s,w,i)=>s+w*inputs[i],0)));
        const o = this.w2.map(row => this.act(row.reduce((s,w,i)=>s+w*h[i],0)));
        return o;
    }
    toJSON(){ return JSON.stringify({w1:this.w1, w2:this.w2}); }
    static fromJSON(json){ return new Brain(0,0,0,JSON.parse(json)); }
}

// =========================
// クリーチャ
// =========================
class Creature{
    constructor(type, brain=null){
        this.type = type; // 'prey' or 'hunter'
        this.x = rand(0,W()); this.y = rand(0,H());
        this.a = rand(0,Math.PI*2);
        this.v = rand(0,1);
        this.energy = ENERGY_MAX;
        this.justHunted = 0;
        this.brain = brain || new Brain();
        this.size = (type==='hunter')?5:4;
    }

    sense(creatures){
        // 近傍の分離・整列・結合のベクトルと、最近傍ターゲット
        let sepX=0, sepY=0, aliX=0, aliY=0, cohX=0, cohY=0;
        let count=0;
        let nearest=null, nd=1e9;

        for(const o of creatures){
            if(o===this) continue;
            const d = dist(this.x,this.y,o.x,o.y);
            if(d>FOV) continue;
            if(d<nd){ nd=d; nearest=o; }
            if(o.type===this.type){
                count++;
                if(d<SEP_DIST){ // 分離
                    sepX += (this.x-o.x)/d;
                    sepY += (this.y-o.y)/d;
                }
                // 整列
                aliX += Math.cos(o.a);
                aliY += Math.sin(o.a);
                // 結合
                cohX += o.x; cohY += o.y;
            }
        }
        if(count>0){
            aliX/=count; aliY/=count;
            cohX = (cohX/count)-this.x;
            cohY = (cohY/count)-this.y;
        }
        return {sepX,sepY,aliX,aliY,cohX,cohY, nearest, nd};
    }

    update(creatures){
        // 感覚
        const s = this.sense(creatures);
        const nx = Math.cos(this.a), ny = Math.sin(this.a);

        // NN入力（v6.1のまま）
        const inputs = [
            nx, ny,
            s.sepX, s.sepY,
            s.aliX, s.aliY,
            s.cohX, s.cohY
        ];

        // NN制御：草食はエネルギー>0の時のみ、肉食は常時
        if(this.energy>0 || this.type==='hunter'){
            const [turn, accel] = this.brain.predict(inputs);
            this.a += turn*0.2;
            this.v += accel*0.05;
        }

        // 速度制限
        const vmax = (this.type==='hunter')?MAX_SPEED_HUNTER:MAX_SPEED_PREY;
        this.v = clamp(this.v, 0, vmax);

        // 移動
        this.x += Math.cos(this.a)*this.v;
        this.y += Math.sin(this.a)*this.v;

        // ラップ
        if(this.x<0) this.x+=W(); if(this.x>W()) this.x-=W();
        if(this.y<0) this.y+=H(); if(this.y>H()) this.y-=H();

        // エネルギー消費
        this.energy -= BASE_DECAY + this.v*SPEED_COST;

        // 草食：同方向整列ボーナス（省エネ）
        if(this.type==='prey'){
            const dot = nx*s.aliX + ny*s.aliY;
            if(dot>0.5) this.energy += 0.02;
        }

        // 衝突ペナルティ（分離の進化圧）
        if(this.type==='prey'){
            if(Math.hypot(s.sepX,s.sepY)>0) this.energy -= 0.02;
        }

        // 捕食チェック
        if(this.type==='hunter'){
            this.checkHunt(creatures, s);
        }

        this.energy = clamp(this.energy, -999, ENERGY_MAX);
    }

    checkHunt(creatures, s){
        // 近い草食を捕食
        for(let i=creatures.length-1;i>=0;i--){
            const o = creatures[i];
            if(o.type==='prey'){
                if(dist(this.x,this.y,o.x,o.y)<10){
                    // 捕食：草食を除去
                    creatures.splice(i,1);
                    this.energy = ENERGY_MAX;
                    this.justHunted = 30;
                    this.reproduce(90, creatures);
                    return;
                }
            }
        }
    }

    reproduce(chance, creatures){
        if(Math.random()*100 < chance){
            const child = new Creature(this.type, this.brain.clone());
            child.x=this.x; child.y=this.y;
            creatures.push(child);
        }
    }

    draw(){
        ctx.beginPath();
        ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
        ctx.fillStyle = (this.type==='hunter')?'#fb7185':'#2dd4bf';
        ctx.fill();
        // 方向
        ctx.beginPath();
        ctx.moveTo(this.x,this.y);
        ctx.lineTo(this.x+Math.cos(this.a)*8, this.y+Math.sin(this.a)*8);
        ctx.strokeStyle='#fff'; ctx.stroke();
        // 停止表示（草食エネルギー枯渇）
        if(this.type==='prey' && this.energy<=0){
            ctx.strokeStyle='rgba(255,255,255,0.4)';
            ctx.strokeRect(this.x-6,this.y-6,12,12);
        }
    }

    // =========================
    // 生存判定（v6.2 変更点）
    // =========================
    isAlive(creatures){
        // v6.2：草食は死なない（停止するだけ）
        if(this.type==='prey') return true;

        // 肉食：最後の1体は無敵
        if(this.type==='hunter'){
            const hunterCount = creatures.filter(c=>c.type==='hunter').length;
            if(hunterCount <= 1) return true;
        }
        // それ以外の肉食のみエネルギーで死亡
        return this.energy > 0;
    }
}

// =========================
// ワールド
// =========================
let creatures = [];
function init(){
    creatures.length=0;
    for(let i=0;i<PREY_COUNT;i++) creatures.push(new Creature('prey'));
    for(let i=0;i<HUNTER_COUNT;i++) creatures.push(new Creature('hunter'));
}
init();

// =========================
// UI（保存/読込）
// =========================
document.getElementById('save').onclick = ()=>{
    const payload = creatures.map(c=>({type:c.type, brain:c.brain.toJSON()}));
    localStorage.setItem('evo_v62_brains', JSON.stringify(payload));
    alert('保存しました');
};
document.getElementById('load').onclick = ()=>{
    const raw = localStorage.getItem('evo_v62_brains');
    if(!raw){ alert('保存データがありません'); return; }
    const arr = JSON.parse(raw);
    // 既存個体の脳に上書き（数が違っても循環適用）
    for(let i=0;i<creatures.length;i++){
        const src = arr[i % arr.length];
        if(src && src.brain){
            creatures[i].brain = Brain.fromJSON(src.brain);
        }
    }
    alert('読み込みました');
};
document.getElementById('reset').onclick = ()=>{ init(); };

// =========================
// ループ
// =========================
function step(){
    ctx.clearRect(0,0,W(),H());

    // 更新
    for(const c of creatures) c.update(creatures);

    // 生存判定（v6.2）
    for(let i=creatures.length-1;i>=0;i--){
        if(!creatures[i].isAlive(creatures)){
            // 肉食が死んだら除去（草食はここで消えない）
            creatures.splice(i,1);
        }
    }

    // 描画
    for(const c of creatures) c.draw();

    // 統計
    const prey = creatures.filter(c=>c.type==='prey').length;
    const hunter = creatures.filter(c=>c.type==='hunter').length;
    const frozen = creatures.filter(c=>c.type==='prey' && c.energy<=0).length;
    document.getElementById('stats').innerHTML =
        `草食: ${prey}（停止: ${frozen}）<br>肉食: ${hunter}<br>総数: ${creatures.length}`;

    requestAnimationFrame(step);
}
step();
</script>
</body>
</html>
