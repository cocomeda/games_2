<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Eco-Evolution v6.1a - Prey Never Die (Auto-Respawn)</title>
<style>
body { margin:0; background:#050505; overflow:hidden; color:#0f0; font-family:Consolas,monospace; }
canvas { display:block; }
.ui {
    position:absolute; top:15px; left:15px;
    background:rgba(0,0,0,0.5); padding:12px; border-radius:8px;
    border:1px solid rgba(0,255,200,0.2); min-width:300px; z-index:100;
}
button { background:#222; color:#fff; border:1px solid #555; padding:5px; font-size:11px; cursor:pointer; }
.btns { display:grid; grid-template-columns:1fr 1fr; gap:5px; margin-top:8px; }
#log { font-size:11px; color:#aaa; margin-top:6px; }
.cyan{color:#0fc;} .red{color:#f55;} .white{color:#fff;}
</style>
</head>
<body>
<div class="ui">
<b>ECO-EVOLUTION v6.1a + Respawn</b><hr>
<div>PREY: <span id="preyCnt">0</span>　HUNTER: <span id="hunterCnt">0</span></div>
<div class="cyan">MEAT: <span id="meatCnt">0</span></div>
<hr>
<div class="btns">
<button onclick="saveBrain('prey')">草食 保存</button>
<button onclick="saveBrain('hunter')">肉食 保存</button>
<button onclick="triggerLoad('prey')">草食 読込</button>
<button onclick="triggerLoad('hunter')">肉食 読込</button>
</div>
<div id="log">解析モード：草食が15以下で肉から復活</div>
</div>
<input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileLoad()">
<canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let creatures=[], meats=[], loadTarget='prey';

////////////////////////////////////////////////////////////
// Neural Network
////////////////////////////////////////////////////////////
class Brain {
    constructor(weights=null){
        this.inputSize=14;
        this.hiddenSize=18;
        if(weights){
            this.w1=new Float32Array(weights.w1).map(v=>Math.random()<0.10? v+(Math.random()-0.5)*0.25:v);
            this.w2=new Float32Array(weights.w2).map(v=>Math.random()<0.10? v+(Math.random()-0.5)*0.25:v);
        }else{
            this.w1=Float32Array.from({length:this.inputSize*this.hiddenSize},()=>Math.random()*2-1);
            this.w2=Float32Array.from({length:this.hiddenSize*2},()=>Math.random()*2-1);
        }
    }
    predict(inputs){
        let h=new Float32Array(this.hiddenSize);
        for(let i=0;i<this.hiddenSize;i++){
            let sum=0;
            for(let j=0;j<this.inputSize;j++) sum+=inputs[j]*this.w1[i*this.inputSize+j];
            h[i]=Math.tanh(sum);
        }
        let out=[0,0];
        for(let i=0;i<2;i++){
            let sum=0;
            for(let j=0;j<this.hiddenSize;j++) sum+=h[j]*this.w2[i*this.hiddenSize+j];
            out[i]=Math.tanh(sum);
        }
        return out;
    }
}

////////////////////////////////////////////////////////////
// Creature
////////////////////////////////////////////////////////////
class Creature{
    constructor(x,y,type,brain=null){
        this.x=x; this.y=y; this.type=type;
        this.energy=100; this.angle=Math.random()*Math.PI*2;
        this.brain=(brain instanceof Brain)?brain:new Brain(brain);
        this.speed=0; this.justHunted=0;
    }
    normDist(d){ return 1/(1+d/120); }

    update(){
        let inputs=[];
        let friends=creatures.filter(c=>c.type===this.type&&c!==this);
        let enemies=creatures.filter(c=>c.type!==this.type);

        let ne=null, dmin=9999;
        for(let e of enemies){
            let d=Math.hypot(this.x-e.x,this.y-e.y);
            if(d<dmin){dmin=d; ne=e;}
        }
        inputs.push(this.normDist(dmin));
        inputs.push(ne? (Math.atan2(ne.y-this.y,ne.x-this.x)-this.angle)/Math.PI:0);

        let fx=0,fy=0,fc=0;
        friends.forEach(f=>{
            let d=Math.hypot(f.x-this.x,f.y-this.y);
            if(d<120){fc++; fx+=f.x-this.x; fy+=f.y-this.y;}
        });
        inputs.push(Math.min(fc,8)/8);
        inputs.push(fc? (Math.atan2(fy,fx)-this.angle)/Math.PI:0);

        let closeCount=0;
        friends.forEach(f=>{
            let d=Math.hypot(f.x-this.x,f.y-this.y);
            if(d<12) closeCount++;
        });
        inputs.push(Math.min(closeCount,5)/5);
        inputs.push(0);

        let ec=0,ex=0,ey=0;
        enemies.forEach(e=>{
            let d=Math.hypot(e.x-this.x,e.y-this.y);
            if(d<120){ec++; ex+=e.x-this.x; ey+=e.y-this.y;}
        });
        inputs.push(Math.min(ec,8)/8);
        inputs.push(ec? (Math.atan2(ey,ex)-this.angle)/Math.PI:0);

        inputs.push(this.energy/100);
        inputs.push(Math.min(this.x,canvas.width-this.x,this.y,canvas.height-this.y)/50);
        inputs.push(this.speed/4);
        inputs.push(Math.sin(this.angle));
        inputs.push(this.justHunted>0?1:0);
        inputs.push(0);

        if(this.type==='prey'){
            if(this.energy>0){
                let [turn,accel]=this.brain.predict(inputs);
                this.angle+=turn*0.25;
                this.speed=3.0*Math.abs(accel);
            }else{
                this.speed=0;
            }
        }else{
            let [turn,accel]=this.brain.predict(inputs);
            this.angle+=turn*0.25;
            this.speed=3.5*Math.abs(accel);
            if(this.justHunted>0) this.speed*=0.3;
        }

        this.x+=Math.cos(this.angle)*this.speed;
        this.y+=Math.sin(this.angle)*this.speed;

        if(this.x<=0||this.x>=canvas.width) this.angle=Math.PI-this.angle;
        if(this.y<=0||this.y>=canvas.height) this.angle=-this.angle;
        this.x=Math.max(0,Math.min(canvas.width,this.x));
        this.y=Math.max(0,Math.min(canvas.height,this.y));

        if(this.type==='prey'){
            let loss=0.01 + this.speed*this.speed*0.01;
            let align=0,ac=0;
            friends.forEach(f=>{
                let d=Math.hypot(f.x-this.x,f.y-this.y);
                if(d<60){
                    let da=Math.abs(Math.sin((f.angle-this.angle)/2));
                    align+=1-da; ac++;
                }
            });
            if(ac>0) loss*= (1 - Math.min(0.4, align/ac*0.5));
            let close=0;
            friends.forEach(f=>{
                let d=Math.hypot(f.x-this.x,f.y-this.y);
                if(d<10) close++;
            });
            loss += close*0.05;
            this.energy-=loss;
            this.checkEatMeat();
        }else{
            const hunterCount = creatures.filter(c=>c.type==='hunter').length;
            const isLastHunter = (hunterCount <= 1);
            if(!isLastHunter){
                let loss=0.05+this.speed*this.speed*0.01;
                this.energy-=loss;
            }else{
                this.energy = Math.max(this.energy, 50);
            }
            this.checkHunt();
        }

        if(this.justHunted>0) this.justHunted--;
        if(this.type==='prey') return true;
        if(this.type==='hunter'){
            const hunterCount = creatures.filter(c=>c.type==='hunter').length;
            if(hunterCount <= 1) return true;
        }
        return this.energy>0;
    }

    checkHunt(){
        for(let i=creatures.length-1;i>=0;i--){
            let c=creatures[i];
            if(c.type==='prey'&&Math.hypot(this.x-c.x,this.y-c.y)<10){
                creatures.splice(i,1);
                this.energy=100;
                this.justHunted=30;
                this.reproduce(90);
                break;
            }
        }
    }

    checkEatMeat(){
        for(let i=meats.length-1;i>=0;i--){
            let m=meats[i];
            if(Math.hypot(this.x-m.x,this.y-m.y)<10){
                meats.splice(i,1);
                this.energy=100;
                this.reproduce(95);
                break;
            }
        }
    }

    reproduce(babyEnergy){
        const baby=new Creature(this.x,this.y,this.type,new Brain({w1:Array.from(this.brain.w1),w2:Array.from(this.brain.w2)}));
        baby.energy=babyEnergy;
        creatures.push(baby);
    }

    draw(){
        ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
        ctx.fillStyle=this.type==='prey'?"#fff":"#f44";
        ctx.beginPath();
        if(this.type==='prey') ctx.arc(0,0,1.5,0,Math.PI*2);
        else{ctx.moveTo(4,0);ctx.lineTo(-3,-2);ctx.lineTo(-3,2);ctx.closePath();}
        ctx.fill(); ctx.restore();
    }
}

////////////////////////////////////////////////////////////
// Save / Load
////////////////////////////////////////////////////////////
function saveBrain(type){
    const list=creatures.filter(c=>c.type===type);
    if(!list.length)return;
    const t=list[Math.floor(Math.random()*list.length)];
    const data={type,w1:Array.from(t.brain.w1),w2:Array.from(t.brain.w2)};
    const blob=new Blob([JSON.stringify(data)],{type:"application/json"});
    const a=document.createElement("a");
    a.href=URL.createObjectURL(blob);
    a.download=`brain_v6.1a_${type}.json`;
    a.click();
}
function triggerLoad(type){loadTarget=type; document.getElementById('fileInput').click();}
function handleFileLoad(){
    const f=document.getElementById('fileInput').files[0];
    if(!f)return;
    const r=new FileReader();
    r.onload=e=>{
        try{
            const d=JSON.parse(e.target.result);
            creatures.filter(c=>c.type===loadTarget).forEach(c=>c.brain=new Brain(d));
            document.getElementById('log').innerText="Brain Loaded.";
        }catch{document.getElementById('log').innerText="Load Error.";}
    };
    r.readAsText(f);
}

////////////////////////////////////////////////////////////
// Init & Loop
////////////////////////////////////////////////////////////
function init(){
    canvas.width=window.innerWidth;
    canvas.height=window.innerHeight;
    creatures=[]; meats=[];
    for(let i=0;i<250;i++) creatures.push(new Creature(Math.random()*canvas.width,Math.random()*canvas.height,'prey'));
    for(let i=0;i<12;i++) creatures.push(new Creature(Math.random()*canvas.width,Math.random()*canvas.height,'hunter'));
}

function animate(){
    ctx.fillStyle='rgba(5,5,5,0.4)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    for(let i=creatures.length-1;i>=0;i--){
        if(!creatures[i].update()){
            if(creatures[i].type==='hunter') meats.push({x:creatures[i].x,y:creatures[i].y});
            creatures.splice(i,1);
        }else creatures[i].draw();
    }

    // ★追加ロジック：草食個体が15以下になったら、すべての肉を草食として復活させる
    const preyList = creatures.filter(c => c.type === 'prey');
    if (preyList.length <= 15 && meats.length > 0) {
        meats.forEach(m => {
            creatures.push(new Creature(m.x, m.y, 'prey'));
        });
        meats = []; // 復活させたので肉リストを空にする
        document.getElementById('log').innerText = "ALERT: Prey Respawned from Meat!";
    }

    meats.forEach(m=>{
        ctx.fillStyle="#0fc";
        ctx.beginPath(); ctx.arc(m.x,m.y,1.2,0,Math.PI*2); ctx.fill();
    });

    document.getElementById('preyCnt').innerText=creatures.filter(c=>c.type==='prey').length;
    document.getElementById('hunterCnt').innerText=creatures.filter(c=>c.type==='hunter').length;
    document.getElementById('meatCnt').innerText=meats.length;

    requestAnimationFrame(animate);
}
window.addEventListener('resize',()=>{canvas.width=window.innerWidth; canvas.height=window.innerHeight;});
init(); animate();
</script>
</body>
</html>
