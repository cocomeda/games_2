<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>重力迷路 - 精密解析Ver.</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root {
    --bg:#0f1220; --panel:#1a1e35; --accent:#4cc9f0; --text:#fff; --muted:#9aa0c4;
}
body { margin:0; background:var(--bg); color:var(--text); font-family:system-ui, sans-serif; overflow:hidden; touch-action:none; }
.ui-layer { position:fixed; top:0; width:100%; padding:15px; box-sizing:border-box; display:flex; justify-content: space-between; pointer-events:none; z-index:5;}
.stats-badge { background:rgba(26,30,53,0.8); padding:8px 12px; border-radius:10px; font-weight:bold; color: var(--accent); font-size: 13px; border: 1px solid rgba(76,201,240,0.3); pointer-events:auto; }

#game-canvas { display:block; }

.setup-screen { position:fixed; inset:0; background:var(--bg); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:100; padding:20px; text-align: center; }
.btn { background:var(--accent); color:#000; border:none; padding:20px 40px; border-radius:15px; font-size:20px; font-weight:bold; cursor:pointer; }

.overlay { position:fixed; inset:0; background:rgba(0,0,0,0.95); display:none; flex-direction:column; align-items:center; z-index:200; overflow-y: auto; padding: 20px 0; }
.overlay-box { width: 90%; max-width: 500px; text-align: center; }
.chart-container { width:100%; height:250px; margin:15px 0; background: rgba(255,255,255,0.03); border-radius: 12px; padding: 10px; box-sizing: border-box; }
</style>
</head>
<body>

<div id="setup" class="setup-screen">
    <h1 style="color:var(--accent)">GRAVITY MAZE</h1>
    <p>タブレットを傾けてボールを操作します</p>
    <p style="font-size:12px; color:var(--muted)">※センサーの利用許可が必要です</p>
    <button class="btn" id="start-btn">センサーを許可して開始</button>
</div>

<div class="ui-layer">
    <span class="stats-badge" id="info">Trial: 0/100</span>
    <span class="stats-badge" id="live-eff">Efficiency: --%</span>
</div>

<canvas id="game-canvas"></canvas>

<div id="overlay" class="overlay">
    <div class="overlay-box">
        <h2 style="color:var(--accent)">RESULT</h2>
        <div id="final-summary" style="margin-bottom:10px; font-weight:bold;"></div>
        <div class="chart-container"><canvas id="timeChart"></canvas></div>
        <div class="chart-container"><canvas id="effChart"></canvas></div>
        <button class="btn" onclick="location.reload()" style="font-size:16px">RETRY</button>
    </div>
</div>

<script>
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
let totalTrials = 40; // テスト用に40回に設定
let currentTrial = 0;
let trialLogs = [];
let ball, target, running = false;
let accel = { x: 0, y: 0 };
const friction = 0.98;

let lastBallPos = { x: 0, y: 0 };
let totalDistance = 0, initialDistance = 0, startTime = 0;

function initCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

class Entity {
    constructor(x, y, radius, color) {
        this.x = x; this.y = y; this.radius = radius; this.color = color;
        this.vx = 0; this.vy = 0;
    }
    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
        ctx.fillStyle = this.color;
        ctx.fill();
        if(this.color === 'transparent') {
            ctx.strokeStyle = '#4cc9f0'; ctx.lineWidth = 3; ctx.stroke();
        }
    }
}

function spawnTarget() {
    const margin = 80;
    target = new Entity(
        margin + Math.random() * (canvas.width - margin*2),
        margin + Math.random() * (canvas.height - margin*2),
        35, 'transparent'
    );
    initialDistance = Math.hypot(ball.x - target.x, ball.y - target.y);
    totalDistance = 0;
    lastBallPos = { x: ball.x, y: ball.y };
    startTime = performance.now();
}

function update() {
    if(!running) return;

    ball.vx += accel.x * 0.5;
    ball.vy += accel.y * 0.5;
    ball.vx *= friction; ball.vy *= friction;
    ball.x += ball.vx; ball.y += ball.vy;

    totalDistance += Math.hypot(ball.x - lastBallPos.x, ball.y - lastBallPos.y);
    lastBallPos = { x: ball.x, y: ball.y };

    if(ball.x < ball.radius || ball.x > canvas.width - ball.radius) ball.vx *= -0.5;
    if(ball.y < ball.radius || ball.y > canvas.height - ball.radius) ball.vy *= -0.5;
    ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x));
    ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y));

    const currentEff = Math.min(100, (initialDistance / Math.max(initialDistance, totalDistance)) * 100);
    document.getElementById('live-eff').textContent = `Eff: ${currentEff.toFixed(1)}%`;

    if(Math.hypot(ball.x - target.x, ball.y - target.y) < ball.radius + target.radius) {
        trialLogs.push({ time: (performance.now() - startTime)/1000, efficiency: currentEff });
        currentTrial++;
        document.getElementById('info').textContent = `Trial: ${currentTrial}/${totalTrials}`;
        if(currentTrial >= totalTrials) finishGame();
        else spawnTarget();
    }

    ctx.fillStyle = 'rgba(15, 18, 32, 0.4)'; // 残像効果
    ctx.fillRect(0,0,canvas.width, canvas.height);
    target.draw();
    ball.draw();
    requestAnimationFrame(update);
}

// センサー許可の核心部分
document.getElementById('start-btn').addEventListener('click', async () => {
    try {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS用
            const response = await DeviceOrientationEvent.requestPermission();
            if (response === 'granted') {
                activateSensor();
            } else {
                alert('センサーの利用が拒否されました。設定を確認してください。');
            }
        } else {
            // AndroidやPC用
            activateSensor();
        }
    } catch (e) {
        alert('エラーが発生しました: ' + e);
    }
});

function activateSensor() {
    window.addEventListener('deviceorientation', (e) => {
        // 画面の向き（縦・横）を考慮
        const orientation = window.orientation || 0;
        if (orientation === 0) { // 縦持ち
            accel.x = e.gamma / 7;
            accel.y = e.beta / 7;
        } else { // 横持ち
            accel.x = (orientation === 90 ? e.beta : -e.beta) / 7;
            accel.y = (orientation === 90 ? -e.gamma : e.gamma) / 7;
        }
    }, true);

    document.getElementById('setup').style.display = 'none';
    initCanvas();
    ball = new Entity(canvas.width/2, canvas.height/2, 18, '#4cc9f0');
    spawnTarget();
    running = true;
    update();
}

function finishGame() {
    running = false;
    document.getElementById('overlay').style.display = 'flex';
    renderStatChart('timeChart', 'time', 'Time (s)', '#4cc9f0');
    renderStatChart('effChart', 'efficiency', 'Path Efficiency (%)', '#ffde03');
}

function renderStatChart(canvasId, key, label, color) {
    const labels = [], averages = [], errors = [];
    for (let i = 0; i < trialLogs.length; i += 10) {
        const chunk = trialLogs.slice(i, i + 10).map(d => d[key]);
        const m = chunk.reduce((a,b)=>a+b)/chunk.length;
        const sd = Math.sqrt(chunk.reduce((a,b)=>a+(b-m)**2,0)/chunk.length);
        averages.push(m);
        errors.push(chunk.length > 1 ? sd/Math.sqrt(chunk.length) : 0);
        labels.push(`${i+1}-${i+10}`);
    }
    new Chart(document.getElementById(canvasId), {
        type: 'line',
        data: {
            labels: labels,
            datasets: [{ data: averages, borderColor: color, backgroundColor: color+'22', fill: true, tension: 0.3 }]
        },
        options: {
            responsive: true, maintainAspectRatio: false,
            plugins: { legend: { display: false }, title: { display: true, text: label, color: '#fff' } },
            scales: { y: { ticks: { color: '#9aa0c4' } }, x: { ticks: { color: '#9aa0c4' } } }
        }
    });
}
window.onresize = initCanvas;
</script>
</body>
</html>
